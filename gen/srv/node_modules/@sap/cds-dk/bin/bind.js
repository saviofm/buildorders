module.exports = Object.assign(cds_bind, {
    options: ['--to', '--for', '--on', '--kind', '--output-file'],
    flags: ['--exec'],
    shortcuts: ['-2', '-4', '-n', '-k', '-o'],
    help: `
# SYNOPSIS

    *cds bind* <service> [<options>]
    *cds bind --exec* [--profile <profile>] [--] <command> <args ...>

    Binds the given service to a service instance by storing connection
    information in *.cdsrc-private.json*
    in your project directory. Credentials are not stored in the file but rather
    retrieved dynamically during *cds watch*.
    Use option *--output-file* to specify a different path or file.

    With *--exec* you can execute arbitrary commands with your service bindings.
    The service bindings are provided
    in the *VCAP_SERVICES* env variable to the command.

# OPTIONS

    *-2 | --to* <instance>[:<key>] | <service-binding> | <secret>
        bind to a given Cloud Foundry instance, Kubernetes service binding or Kubernetes secret.

    *-4 | --for* <profile>
        store binding information under <profile> in *.cdsrc-private.json*. Default *hybrid* is used
        if '--for' is not specified

    *-n | --on* cf | k8s
        bind to service on Cloud Foundry or Kubernetes, defaults to Cloud Foundry

    *-k | --kind* <kind>
        the kind of service

    *-o | --output-file* <path>
        save bindings to the given *.cdsrc.json* or *package.json* file. Default is *.cdsrc-private.json*.
        If *path* is a directory, then it will save it to the *.cdsrc.json* file in that directory.

# EXAMPLE

    cds bind --to my-hdi-container
    cds bind --to my-hdi-container,my-xsuaa
    cds bind uaa --to my-xsuaa:my-xsuaa-key --kind xsuaa --for myprofile

    cds bind --to my-hdi-container --output-file .
    cds bind --to my-hdi-container --output-file package.json

    cds bind --to my-hdi-container --on k8s
    cds bind --to my-hdi-container --for my-profile
`
});

const os = require('os');
const IS_WIN = os.platform() === 'win32';

const { CliError } = require('../lib/client/helper/errors');
const { bind, parseProfile } = require('../lib/bind');


async function cds_bind(args, options) {

    if (options.exec) {
        process.env.CDS_ENV = parseProfile(process.env.CDS_ENV);
        if (options.for) {
            console.warn('Parameter --for is not supported in combination with --exec. Its value will be ignored.');
        }
        return cds_bind_exec(args)
    }

    // Check if cds command was bind. Don't abort in case of deploy
    if (process.env.CDS_ENV && process.argv[2] === 'bind') {
        throw new CliError('Option --profile is no longer supported. Use --for instead to specify the profile to use when storing connection settings.');
    }
    options.for = options.for ?? 'hybrid';

    if (!options.to) {
        throw new CliError(`Use option --to or -2 to specify the target instance, e.g. cds bind --to myInstance:myService`);
    }

    if (args.length > 1) {
        throw new CliError(`Too many arguments: Please specify only one or no service.`);
    }

    options.serviceArg = args[0]
    options.targets = options.to.split(/,/g);

    if (options.targets.length >= 2 && options.serviceArg) {
        throw new CliError(`Service argument cannot be specified together with multiple targets ('--to') services. Use one service per call or omit the service argument.`);
    }

    if (options.targets.length >= 2 && options.kind) {
        throw new CliError(`The option '--kind' cannot be specified together with multiple targets ('--to') services. Use one service per call or omit the '--kind' option.`);
    }

    await bind({
        ...options,
        outputFile: options['output-file']
    });
}

async function cds_bind_exec(command) { // eslint-disable-lint
    const cds = require('../lib/cds');
    const env = cds.env.for('cds', process.cwd());

    const BindingManager = require('../lib/bind/bindingManager')
    const bindingManager = new BindingManager({ env })
    const bindingEnv = await bindingManager.bindingEnv()
    const processEnv = Object.assign(process.env, bindingEnv)

    execAndExit({ env: processEnv }, ...command);
}

function execAndExit(options, command, ...args) {
    const { spawnSync } = require('child_process');
    // use shell with Windows only; without output is not visible and some commands cannot be run
    const result = spawnSync(command, args, {
        stdio: 'inherit',
        shell: IS_WIN,
        ...options
    });
    process.exit(result.status);
}
