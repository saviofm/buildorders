const path = require('path')
const mtxAdapter = require('./mtx-adapter')
const { createProjects } = require('./extension-project')
const cds = require('@sap/cds')
const LOG = cds.log('mtx'), DEBUG = cds.debug('mtx')
const { mkdirp, fs: fsUtils  } = require('@sap/cds').utils
const fs = fsUtils.promises

// REVISIT: Exported private functions
module.exports._hasMtEnv = () => cds.requires.multitenancy || (cds.env.requires['cds.xt.DeploymentService'] && cds.env.requires['cds.xt.ModelProviderService'])
module.exports._hasExtensibilityEnv = () => cds.requires.extensibility || cds.env.requires['cds.xt.ExtensibilityService']

module.exports._getExtensionProjectDirectory = function(dir) {
    if (dir) {
        LOG.log(`Project directory ${dir} does not exist. ${dir} has been created.`)
        return mkdirp(dir)
    }
    return mtxAdapter.mkdirTemp()
}

class MigrationResult {
    constructor() {
        this.connectedTenants = []
        this.results = {}
        this.hasError = false
    }

    addTenant(tenant, meta = true) {
        this.connectedTenants.push(tenant)
        if (meta) this.connectedTenants.push(mtxAdapter.getMetaTenantName(tenant))
    }

    log(tenant, message) {
        if (!this.results[tenant]) this.results[tenant] = []
        this.results[tenant].push(message)
        LOG.log(message)
    }

    error(tenant, message, error) {
        if (!this.results[tenant]) this.results[tenant] = []
        this.results[tenant].push(`${message} ${error.message}`)
        LOG.error(message, error)
        this.hasError = true
    }

    logResult(dry = false) {
        LOG.log(`Migration Result ${dry ? '(dry run only)' : ''}:`)
        for (const tenant of Object.keys(this.results)) {
            for (const line of this.results[tenant]) LOG.log(`[${tenant}] ${line}`)
        }
    }
}

function getT0() {
    return cds.env.requires.multitenancy?.t0 ?? 't0'
}

module.exports.cleanupMetatenants = async function cleanup(tenants, options) {
    const migrationResult = new MigrationResult()
    const { dry } = options

    let tenantsToCleanup = tenants
    // handle tenant "*" -> retrieve all tenants
    if (tenants.includes('*')) {
        tenantsToCleanup = await mtxAdapter.getAllTenantIds()
    }

    const t0 = getT0()
    migrationResult.addTenant(t0, false) // adds tenant for disconnect

    const metatenantsToCleanup = {}
    for (const tenant of tenantsToCleanup) {
        if (tenant === t0) continue
        const metatenant = mtxAdapter.getMetaTenantName(tenant)
        metatenantsToCleanup[tenant] = metatenant
    }

    for (const [tenant, metatenant] of Object.entries(metatenantsToCleanup)) {
        migrationResult.addTenant(metatenant, false)

        try {
            // check if tenant was already migrated
            try {
                const migrated = tenant !== '__META__' ? await mtxAdapter.isMigrated(tenant) : { timestamp: true }
                if (!migrated.timestamp) {
                    migrationResult.error(tenant, `Tenant ${tenant} was not migrated. Skipping cleanup.`, new Error(`Tenant ${tenant} was not migrated`))
                    continue
                }
            } catch (e) {
                if (e.status === 404) {
                    migrationResult.log(tenant, `No @sap/cds-mtx meta-tenant found for ${tenant}. Skipping cleanup.`)
                    continue
                } else throw e
            }

            // do the cleanup
            if (!dry) {
                const ds = await cds.connect.to('cds.xt.DeploymentService')
                await ds.unsubscribe(metatenant)
            }
            migrationResult.log(metatenant, `Metatenant ${metatenant} successfully deleted.`)
        } catch (error) {
            migrationResult.error(metatenant, `Cleanup of tenant ${metatenant} failed.`, error)
            continue
        }
    }

    // only cleanup __META__ if all other meta tenants have been cleaned up successfully
    if (!dry && !migrationResult.hasError) {
        const ds = await cds.connect.to('cds.xt.DeploymentService')
        const commonMetaTenant = '__META__'
        await ds.unsubscribe(commonMetaTenant)
        migrationResult.log(commonMetaTenant, `Common metatenant ${commonMetaTenant} successfully deleted.`)
    }

    LOG.log('Cleanup done')
    return migrationResult
}

module.exports.checkMigration = async function checkMigration(req) {
    const { tenant } = req.data
    if (await mtxAdapter.hasExtensions(tenant)) {
        if (module.exports._hasExtensibilityEnv()) {
            if (!await mtxAdapter.isMigrated(tenant))
                req.reject(422, `Upgrade of tenant ${tenant} aborted. Extensions have not been migrated yet`)
        } else {
            req.reject(422, `Upgrade of tenant ${tenant} aborted. Old MTX Extensions exist but extensibility is not configured (cds.requires.extensibility is false)`)
        }
    }
}

module.exports.migrate = async function migrate(tenants, options) {

    const { directory, dry, force, tagRule: tagRegex, tag: defaultTag, "skip-verification": skipVerification, "ignore-migrations": ignoreMigrations } = options

    const migrationResult = new MigrationResult()
    let tenantsToMigrate = tenants

    // handle tenant "*" -> retrieve all tenants
    if (tenants.includes('*')) {
        tenantsToMigrate = await mtxAdapter.getAllTenantIds()
    }

    const t0 = getT0()
    migrationResult.addTenant(t0, false) // adds tenant for disconnect

    const extensibility = module.exports._hasExtensibilityEnv()
    let projectsDir

    for (const tenant of tenantsToMigrate) {

        migrationResult.addTenant(tenant)

        // skip migration of t0
        if (tenant === t0) {
            migrationResult.log(tenant, `Skipping internal tenant ${tenant}.`)
            continue
        }

        try {
            // check if tenant was already migrated
            try {
                const migrated = await mtxAdapter.isMigrated(tenant)
                if (migrated?.timestamp && !force) {
                    migrationResult.log(tenant, `Tenant ${tenant} is already migrated. Skipping migration.`)
                    continue
                }
            } catch (e) {
                if (e.status === 404) {
                    migrationResult.log(tenant, `No @sap/cds-mtx meta-tenant found for ${tenant}. Skipping migration.`)
                    continue
                } else throw e
            }

            // Get from old mtx
            const metadata = await mtxAdapter.getMetadata(tenant)

            if (extensibility) {

                // update tenant metadata + extension tables
                // add extension tables - TODO could also be done on-the-fly with push
                const extTables = await cds.load(`${__dirname}/../../db/extensions.cds`)
                cds.model = cds.db.model = cds.compile.for.nodejs(extTables)
                if (!dry) {
                    // disable extension deployment to avoid lengthy redeployments when doing the push()
                    const ds = await cds.connect.to('cds.xt.DeploymentService')
                    ds.prepend (srv => srv.on ('extend', () => { }))

                    try {
                        await cds.tx({ tenant}, tx => tx.run(SELECT.one(1).from('cds.xt.Extensions')))
                        // add metadata in case it had not been added before
                        await _addMetadata(tenant, metadata)
                    } catch (error) {
                        LOG.log('cds.xt.Extensions not yet deployed, deploying ...')
                        DEBUG && DEBUG(error)
                        await ds.subscribe({ tenant, metadata, options: { csn: extTables } }) // also creates metadata ...
                    }
                }

                // run extend -> into memory?
                const mtxExtension = await mtxAdapter.getExtension(tenant)

                if (mtxExtension) {
                    // allow different folder from command line to preserve results
                    projectsDir = projectsDir || await module.exports._getExtensionProjectDirectory(directory)
                    const tenantProjectFolder = path.join(projectsDir, tenant)

                    const tags = await createProjects(mtxExtension, tenantProjectFolder, tagRegex, defaultTag)

                    // upload and verify extensions
                    // iterate all tags
                    migrationResult.log(tenant, `Created projects for tags "${tags}"`)

                    // Verify migrated extension
                    if (!skipVerification) {
                        try {
                            // check diff and abort if necessary
                            const existingCsn = await mtxAdapter.getCsn(tenant)

                            await fs.mkdir(path.join(tenantProjectFolder, 'mtx_original_csn'), { recursive: true })
                            await fs.writeFile(path.join(tenantProjectFolder, 'mtx_original_csn', 'csn.json'), JSON.stringify(existingCsn, null, 2))

                            await _verifyExtension(migrationResult, tenantProjectFolder, tenant, tags, existingCsn, options)
                            migrationResult.log(tenant, `Extension verification successful for tenant ${tenant} [${tenantProjectFolder}]`)
                        } catch (error) {
                            migrationResult.error(tenant, `Extension verification failed for tenant ${tenant} [${tenantProjectFolder}]), skipping migration.`, error)
                            continue
                        }
                    } else {
                        migrationResult.log(tenant, `Extension verification skipped for tenant ${tenant}`)
                    }

                    for (const tag of tags) {
                        const projectFolder = path.join(tenantProjectFolder, tag)

                        if (!dry) {
                            try {
                                const extensionTgz = await fs.readFile(path.join(projectFolder, 'gen', 'extension.tgz'))
                                const es = await cds.connect.to('cds.xt.ExtensibilityService')
                                await es.tx({ tenant, user: new cds.User.Privileged }, tx =>
                                    tx.push(extensionTgz.toString('base64'), tag)
                                )
                                migrationResult.log(tenant, `Extension for tenant ${tenant} and tag ${tag} pushed.`)
                            } catch (error) {
                                migrationResult.error(tenant, `Error pushing extension for tenant ${tenant} and tag ${tag}`, error)
                                continue
                            }
                        }
                    }
                }
            } else {
                // check if extensions exist -> abort if yes
                if (await mtxAdapter.hasExtensions(tenant)) throw new Error(`Extensions exist but extensibility is not configured (cds.requires.extensibilty is false)`)

                if (!dry) {
                    await _addMetadata(tenant, metadata)
                    migrationResult.log(tenant, `Metadata for tenant ${tenant} added.`)
                }
            }

            if (!dry) await mtxAdapter.setMigrated(tenant)
            migrationResult.log(tenant, `Migration of tenant ${tenant} done.`)
        } catch (error) {
            migrationResult.error(tenant, `Migration of tenant ${tenant} failed.`, error)
        }
    }

    // cleanup tmpdir, keep directory if it was set externally
    if (!directory && projectsDir) await fs.rm(projectsDir, { recursive: true, force: true })

    LOG.log('Extension migration done')
    return migrationResult
}

async function _addMetadata(tenant, metadata) {
    const t0  = getT0()
    // TODO Upsert ?
    try {
        await cds.tx({ tenant: t0 }, tx =>
          tx.run(INSERT.into('cds.xt.Tenants', { ID: tenant, metadata: JSON.stringify(metadata) }))
        )
    } catch (e) {
        if (e.message !== 'ENTITY_ALREADY_EXISTS') throw e
    }
}

async function _verifyExtension(migrationResult, tenantProjectFolder, tenant, tags, existingCsn, options) {

    const { "ignore-migrations": ignoreMigrations  } = options

    const projectFolders = tags

    const mp = await cds.connect.to('cds.xt.ModelProviderService')
    const isExtended = await (async () => { try { return await mp.isExtended(tenant) } catch(error) { return false } })()
    const mainCsn = await mp.getCsn({ tenant, flavor: 'inferred', activated: true })

    if (!mainCsn) throw new Error(`Verification error for tenant ${tenant}: Empty base model`)

    let previewCsn = mainCsn

    // calculate model with extensions to be pushed later
    for (const projectFolder of projectFolders) {
        const extensionCsnString = await fs.readFile(path.join(tenantProjectFolder, projectFolder, 'gen', 'ext', 'extension.csn'))
        const extensionCsn = JSON.parse(extensionCsnString)
        // do not apply extensions if mp.getCsn already contained extensions
        // TODO refine check
        if (!isExtended) previewCsn = cds.extend(previewCsn).with(extensionCsn)
    }

    // ensure flavor
    const inferredExistingCsn = cds.compile({inferred: existingCsn}, {flavor: 'inferred'})

    const existingHana = cds.compiler.to.hdi.migration(inferredExistingCsn)
    const newHana = cds.compiler.to.hdi.migration(previewCsn)

    const diffMessages = []

    // are artifacts lost?
    const hanaDiffNewToOld = cds.compiler.to.hdi.migration(cds.minify(previewCsn), {}, cds.minify(existingHana.afterImage))
    if (hanaDiffNewToOld.deletions.length) {
        diffMessages.push(`Migrated model is missing artifacts:\n ${hanaDiffNewToOld.deletions.map( ({ name, suffix }) => `${name}${suffix}\n`)}`)
    }

     if (hanaDiffNewToOld.migrations.length) {
        const ignore = ignoreMigrations ?? '^sap.common'
        const relevantMigrations = hanaDiffNewToOld.migrations.filter( m => !new RegExp(ignore).test(m.name))
        migrationResult.log(tenant, `Table migrations found but ignored for /${ignore}/`)

        if (relevantMigrations.length) diffMessages.push(`Table migrations found\n` +
            `${relevantMigrations.map( ({ name, suffix, changeset }) => `  ${name}${suffix}: ${changeset.map(({sql}) => sql)}\n`)}`)
    }

    // does the new model contain more artifacts?
    const MTXS_ENTITIES = ['cds.xt.Extensions']
    const hanaDiffOldToNew = cds.compiler.to.hdi.migration(cds.minify(inferredExistingCsn), {}, cds.minify(newHana.afterImage)) // cds.xt.Extensions is allowed
    const filteredDeletions = hanaDiffOldToNew.deletions.filter( ({name}) => !MTXS_ENTITIES.includes(name))
    if (filteredDeletions.length) {
        diffMessages.push(`Migrated model has additional artifacts:\n ${hanaDiffOldToNew.deletions.map( ({ name, suffix }) => `${name}${suffix}\n`)}`)
        throw new Error(`Verification error for tenant ${tenant}: migrated model has additional artifacts:\n ${hanaDiffOldToNew.deletions.map( ({ name, suffix }) => `${name}${suffix}\n`)}`)
    }

    if (diffMessages.length) throw new Error(`Verification error for tenant ${tenant}:\n${diffMessages.join('\n')}`)
}