const path = require('path');
const fs = require('fs').promises;

const { CliError } = require('./helper/errors');

const MTX_URL_PATH_PREFIX = 'mtx/v1/model/';
const CUSTOM_FILE_URL_SUFFIX = 'customTenantContent';

module.exports = class BaseCommand {

    static get CUSTOM_FILE_URL_SUFFIX() { return CUSTOM_FILE_URL_SUFFIX; }

    static async checkProject(folder) {
        const exists = await fs.access(path.join(folder, 'package.json')).then(() => true).catch(() => false)
        return exists;
    }

    static handleHttpError(error, params, { url, command } = {}) {
        url = url ?? params.get('appUrl');
        const prefix = `Request to ${url} failed`;
        switch (error.response?.status) {
            case 401:
                throw new CliError(`${prefix}: invalid authentication.\nRetry with valid passcode${
                    params.has('passcodeUrl') ? ` from ${params.get('passcodeUrl')}` : ''
                } or username/password (required if SaaS app is configured with mocked-auth).`, { error, command });
            case 403:
                throw new CliError(prefix + ': insufficient authorization. Ensure client has all necessary roles.', { error, command });
            case 404:
                throw new CliError(prefix + ': resource not found.', { command });
            case 422:
                // Compilation or native-extension error.
                throw new CliError(prefix + '.', { error, command });
            default:
                // Unexpected error should be transparent to user.
                if (!require('..').debug('axios')) {
                    error.config?.auth && (error.config.auth = '...'); // TODO use &&= with Node > 14
                    delete error.request;
                    delete error.response;
                }
                throw error;
        }
    }

    static concatUrls(base, ...paths) {
        function trimBeginSlash(str) {
            return str.replace(/^\//, '');
        }
        function trimEndSlash(str) {
            return str.replace(/\/$/, '');
        }
        function trimSlashes(str) {
            return trimBeginSlash(trimEndSlash(str));
        }
        const concatenated = new URL(base);
        concatenated.pathname = trimEndSlash(concatenated.pathname) + '/' +
            paths.map((p, i) => i < paths.length - 1 ? trimSlashes(p) : trimBeginSlash(p)).join('/');
        return concatenated.toString();
    }

    static getMtxApiUrl(url, action) {
        return BaseCommand.concatUrls(url, MTX_URL_PATH_PREFIX, action);
    }

    static getMtxApiUrlSync(url, action) {
        return BaseCommand.concatUrls(url, MTX_URL_PATH_PREFIX, action);
    }
}
