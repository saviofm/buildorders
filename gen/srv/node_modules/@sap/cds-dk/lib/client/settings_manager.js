const fs = require('fs');
const os = require('os');
const path = require('path');
const axios = require('axios');

const cds = require('../cds');
const DEBUG = cds.debug('cli');
const { requireGlobal } = require('./helper/dependency_helper');
const { getAppFromSuggestions, getSubdomain } = require('./helper/cf_helper');
const isBas = require('./helper/env_helper');
const Question = require('./helper/question');
const { CliError } = require('./helper/errors');
const { httpSchema, httpsSchema, schemaRegex, localhostRegex } = require('./helper/url_helper');
const { capitalize } = require('./helper/string_helper');

const { ParamCollection, Persistence } = require('./params');

const CONFIG_SUBDIRS = {
    linux: '.config',
    darwin: path.join('Library', 'Preferences'),
    win32: 'AppData'
};

const TOKEN_STORAGE_DESC = {
    plain: 'plain-text storage',
    keyring: 'keyring'
};

const KEYRING_DESC = {
    linux: 'libsecret',
    darwin: 'Keychain',
    win32: 'Credential Vault'
};

const MTX_FULLY_QUALIFIED = 'com.sap.cds.mtx';
const OAUTH_PATH_OLD_MTX = '/mtx/v1/oauth/token';
const OAUTH_PATH_STREAMLINED_MTX = '/-/cds/login/token';

const SETTINGS_DIR = path.join(os.homedir(), CONFIG_SUBDIRS[os.platform()] || '', MTX_FULLY_QUALIFIED);
const SETTINGS_FILE = 'projects.json';
const AUTH_FILE = 'auth.json';

const CONFIG = {
    paths: {
        settings: path.join(SETTINGS_DIR, SETTINGS_FILE),
        auth: path.join(SETTINGS_DIR, AUTH_FILE)
    },
    keyringDesignation: KEYRING_DESC[os.platform()] || 'not supported'
};

let keytar;

function other(tokenStorage) {
    if (!tokenStorage) {
        return tokenStorage;
    }
    return tokenStorage === 'plain'
           ? 'keyring'
           : 'plain';
}

function getProjectFolder(params) {
    if (params.has('projectFolder')) {
        const maybeExistentPath = path.resolve(params.get('projectFolder'));
        return maybeExistentPath;
    }
    return fs.realpathSync('.');
}

async function getAppUrlAndSubdomainFromSuggestions(params) {
    const app = await getAppFromSuggestions();
    if (!app) {
        return;
    }

    params.set('appUrl', app.url);

    if (!params.has('subdomain')) {
        params.set('subdomain', await getSubdomainFromCfAndNotify(app.name));
    }
}

async function getSubdomainFromCfAndNotify(appName) {
    const subdomain = await getSubdomain(appName);
    if (subdomain) {
        console.log('Subdomain determined from CF app environment:', subdomain);
    } else {
        console.warn('Failed to determine subdomain from CF app environment');
    }
    return subdomain;
}

async function getTokenBaseUrl(params, renewUrl) {
    if (params.has('tokenUrl') && !renewUrl) {
        return params.get('tokenUrl');
    }
    if (!params.has('appUrl')) {
        throw new CliError('Failed to determine token URL: app URL not given');
    }
    const baseUrl = new URL(params.get('appUrl'));
    const cleanPathname = pathname => baseUrl.pathname.replace(/\/?$/, pathname);
    const getBaseUrl = pathname => {
        const url = new URL(baseUrl.toString());
        url.pathname = cleanPathname(pathname);
        return url;
    };

    let existingPath;
    const oauthPaths = [OAUTH_PATH_STREAMLINED_MTX];
    for (const path of oauthPaths) {
        try {
            await axios.head(getBaseUrl(path).toString());
            existingPath = path;
            break;
        } catch (error) {
            if ([401, 404].includes(error.response?.status)) {
                continue;
            }
            throw error;
        }
    }
    existingPath = existingPath ?? OAUTH_PATH_OLD_MTX; // REVISIT can this just be included in the array?
    return getBaseUrl(existingPath).toString();
}

function getKeyringAccountName(params) {
    return `${params.get('appUrl')}|${params.get('subdomain')}`;
}

function logConfigPaths() {
    DEBUG?.(`Settings are stored in ${CONFIG.paths.settings}`);
    DEBUG?.(`Authentication data is stored in ${CONFIG.paths.auth} (${TOKEN_STORAGE_DESC.plain}) or ${CONFIG.keyringDesignation} (${TOKEN_STORAGE_DESC.keyring})`);
}

function notifyLoggedIn(params) {
    return params.get('renewLogin')
           ? console.log.bind(console)
           : DEBUG;
}

function emptyData(all) {
    return all ? {} : new ParamCollection();
}

class SettingsManager {

    static init() {
        logConfigPaths();
    }

    static get config() {
        return CONFIG;
    }

    // Call with 'projectFolder' param as a resolved path.
    static async saveSettings(params) {
        DEBUG?.(`Saving settings for project ${params.get('projectFolder')}`);

        const paramsMap = params.toEntries(Persistence.setting);
        if (params.has('username')) {
            // Save username only for localhost for security reasons.
            if (localhostRegex.test(params.get('appUrl'))) {
                console.log(`Saving username${(params.get('isEmptyPassword') ? ' and empty-password hint' : '')} with project settings.`);
            } else {
                DEBUG?.('Not saving username because app is not recognized to run on localhost.');
                delete paramsMap.username;
                delete paramsMap.isEmptyPassword;
            }
        }
        await this._saveToFile(params.get('projectFolder'), paramsMap);

        if (params.get('skipToken') || !params.has('token')) {
            return;
        }

        if (params.get('clearOtherTokenStorage')) {
            // Delete token from the other storage.
            params.delete('clearOtherTokenStorage');
            await this.deleteToken(params, true);
        }

        if (params.get('tokenStorage') === 'plain') {
            await this._saveAuthToFile(params, params.toEntries(Persistence.auth));
        } else if (params.get('tokenStorage') === 'keyring') {
            await this.setKeytar(params);
            await this._saveAuthToKeyring(params, params.toEntries(Persistence.auth));
        } else {
            console.log('Note: the authentication token is not saved by default. To save the token for later commands, please run `cds login`.');
        }
    }

    static async loadAndMergeSettings(params, logout = false) {
        const projectFolder = getProjectFolder(params);
        params.set('projectFolder', projectFolder);

        const loadedSettings = await this._loadFromFile(projectFolder);
        DEBUG?.(`Loaded project settings for ${params.get('projectFolder')}: ${loadedSettings.format()}`);
        const loadedAppUrl = loadedSettings.get('appUrl');

        if (params.has('passcode') && loadedSettings.has('username')) {
            console.log(`Unsetting username${(loadedSettings.has('isEmptyPassword') ? ' and empty-password hint' : '')}`);
            loadedSettings.delete('username');
            loadedSettings.delete('isEmptyPassword');
        }

        params.mergeLower(loadedSettings);

        if (params.has('username')) {
            params.set('skipToken', true);
        }
        await this.updateUrls(params, logout, loadedAppUrl);
        await this.setKeytar(params, logout);
        await this.addAuth(params, logout);
        DEBUG?.(`Effective project settings: ${params.format()}`);
    }

    static async updateUrls(params, logout, loadedAppUrl) {
        async function addAppUrl() {
            // Prefix URL schema
            if (params.has('appUrl')) {
                const appUrl = params.get('appUrl');
                if (!schemaRegex.test(appUrl)) {
                    if (localhostRegex.test(appUrl)) {
                        params.set('appUrl', httpSchema + appUrl);
                    } else {
                        params.set('appUrl', httpsSchema + appUrl);
                    }
                    DEBUG?.(`Added schema to app URL: ${params.get('appUrl')}`);
                }
            }

            if (!logout && !params.has('appUrl')) {
                // Get appUrl from CF
                DEBUG?.('App URL not given');
                await getAppUrlAndSubdomainFromSuggestions(params);
            }

            // Check required param: appUrl
            if (!params.has('appUrl')) {
                throw new CliError('App URL not given. Please specify it or log in to Cloud Foundry and repeat this command.');
            }
        }
        async function renewTokenUrl() {
            const renewUrl = params.get('appUrl') !== loadedAppUrl;
            if (!params.get('tokenUrl') || renewUrl) {
                params.set('tokenUrl', await getTokenBaseUrl(params, renewUrl));
            }
        }

        await addAppUrl();

        if (!logout && !params.get('skipToken')) {
            await renewTokenUrl();
        }
    }

    static async setKeytar(params, logout = false) {
        if (params.get('skipToken')) {
            return;
        }
        if (isBas()) {
            if (params.get('tokenStorage') === 'keyring') {
                console.log('NOTE:', capitalize(TOKEN_STORAGE_DESC.keyring), 'not supported on SAP Business Application Studio. Switching to', TOKEN_STORAGE_DESC.plain, '.');
                params.set('tokenStorage', 'plain');
            }
            return;
        }
        keytar = requireGlobal('keytar');
        if (keytar) {
            return;
        }
        // keytar missing

        if (params.get('tokenStorage') === 'keyring' && params.get('saveData')) {
            // Explicit login w/o plain-text storage enabled
            throw new CliError(capitalize(TOKEN_STORAGE_DESC.keyring) + ' requested but keytar not installed. ' +
                'Run `npm install -g keytar` or switch to ' + TOKEN_STORAGE_DESC.plain + ' by adding `--plain` (discouraged).');
        }

        const doLog = params.get('saveData') || logout
            ? console.log.bind(console) // Explicit login/logout call
            : DEBUG;
        doLog?.(`Disabling ${TOKEN_STORAGE_DESC.keyring} functionality: keytar not found. Run \`npm install -g keytar\` to install it.`);
    }

    static async addAuth(params, logout) {
        async function addPassword() {
            if (params.get('isEmptyPassword')) {
                params.set('password', '');
            } else {
                params.set('password', await Question.askQuestion('Password: ', undefined, true));
                console.log();
            }
        }
        async function addClientSecret() {
            params.set('clientsecret', await Question.askQuestion('clientsecret: ', undefined, true));
            console.log();
            if (params.get('clientsecret') === '') {
                throw new CliError('Clientsecret cannot be empty');
            }
        }
        async function addKey() {
            params.set('key', await Question.askQuestion('key: ', undefined, true));
            console.log();
            if (params.get('key') === '') {
                throw new CliError('Key cannot be empty');
            }
        }
        async function addPasscode() {
            const prompt = `Passcode${params.get('passcodeUrl') ? ' (visit ' + params.get('passcodeUrl') + ' to generate)' : ''}: `;
            params.set('passcode', (await Question.askQuestion(prompt, undefined, true)).trim());
            console.log();
            if (params.get('passcode') === '') {
                throw new CliError('Passcode cannot be empty');
            }
        }
        function setRelevantAuth(auth) {
            if (!(auth.keyring.has('tokenStorage') || auth.plain.has('tokenStorage'))) {
                // Saved auth data not present.
                return;
            }
            let storage = params.get('tokenStorage');
            if (auth.keyring.has('tokenStorage') && auth.plain.has('tokenStorage')) {
                // Both storage places contain data: retrieve from selected or keyring.
                storage = storage || 'keyring';
                DEBUG?.('WARNING: authentication data found in both kinds of storage. ' +
                    `Using data from ${TOKEN_STORAGE_DESC[storage]}; other storage will be cleared when next saving.`);

                params.merge(auth[storage]);
                params.set('clearOtherTokenStorage', true);

            } else if (storage && auth[other(storage)].has('tokenStorage')) {
                // Selected storage contains no data, but other one does: retrieve from other storage, but earmark migration to selected one.
                DEBUG?.(`Using authentication data from ${TOKEN_STORAGE_DESC[other(storage)]}; will be migrated to other storage on save.`);

                params.merge(auth[other(storage)]);
                params.set('tokenStorage', storage);
                params.set('clearOtherTokenStorage', true);

            } else {
                // One storage contains data, and there's no conflict with selection.
                const storage = auth.keyring.get('tokenStorage') || auth.plain.get('tokenStorage');
                DEBUG?.(`Using authentication data from ${TOKEN_STORAGE_DESC[storage]}.`);

                params.merge(auth[storage]);
            }
        }

        if (params.has('username')) {
            if (!params.has('password') && !logout) {
                await addPassword();
            }
            if (params.get('password') === '') {
                params.set('isEmptyPassword', true);
            } else {
                params.delete('isEmptyPassword');
            }
            DEBUG?.('Ignoring any saved authentication data because username is given');
            return;
        } else {
            params.delete('isEmptyPassword');
        }

        if (params.get('skipToken')) {
            return;
        }

        if (params.get('clientid') && !logout) {
            if (params.has('key')) {
                if (params.get('key') === 'ask') {
                    params.delete('key');
                    await addKey();
                }
            } else if (!params.has('clientsecret')) {
                await addClientSecret();
            }
        }

        const auth = {
            plain: await this._loadAuthFromFile(params.get('appUrl'), params.get('subdomain')),
            keyring: await this._loadAuthFromKeyring(params.get('appUrl'), params.get('subdomain'))
        };

        setRelevantAuth(auth);

        if (!logout && !params.has('token') && !params.has('passcode') && !params.has('clientsecret') && !params.has('key')) {
            await addPasscode();
        }
    }

    static async deleteToken(params, fromOtherStorage = false) {
        const allParams = params.clone();
        await this.loadAndMergeSettings(allParams, true);

        const target = `URL ${allParams.get('appUrl')}, subdomain '${allParams.get('subdomain')}'`;
        let fromStorage = fromOtherStorage && other(params.get('tokenStorage'));
        const deleteBoth = !fromStorage && allParams.get('tokenStorage') && allParams.get('clearOtherTokenStorage');

        DEBUG?.(`Deleting authentication data${fromOtherStorage ? ' from other storage' : ''} for ${target}`);

        fromStorage = fromStorage || allParams.get('tokenStorage');
        if (!fromStorage) {
            console.log('Failed to delete authentication data: none found for', target);
            return;
        }

        if (fromStorage === 'plain' || deleteBoth) {
            await this._saveAuthToFile(allParams, null);
        }
        if (fromStorage === 'keyring' || deleteBoth) {
            await this._saveAuthToKeyring(allParams, null);
        }
    }

    static async deleteSettingsWithoutToken(params) {
        const projectFolder = getProjectFolder(params);
        await this._saveToFile(projectFolder, null);
    }

    static async deleteInvalid() {
        const settingsByFolder = await this._loadFromFile(undefined);
        const deletionFolders = [];
        const deletionUrlsAndSubdomains = new Set();

        Object.entries(settingsByFolder)
            .filter(entry => ! fs.existsSync(entry[0]))
            .forEach(entry => {
                delete settingsByFolder[entry[0]];
                deletionFolders.push(entry[0]);
                deletionUrlsAndSubdomains.add(entry[1].appUrl + '|' + entry[1].subdomain);
            });

        await this._saveAllSettingsToFile(settingsByFolder);

        if (deletionFolders.length) {
            for (const urlAndSubdomain of deletionUrlsAndSubdomains.values()) {
                const appUrl = urlAndSubdomain.replace(/\|.*/, '');
                const subdomain = urlAndSubdomain.replace(/.*\|/, '');
                const urlReference = Object.values(settingsByFolder).find(settings => settings.appUrl === appUrl && settings.subdomain === subdomain);
                if (!urlReference) {
                    await this.deleteToken(new ParamCollection({ appUrl, subdomain }));
                }
            }
            console.log('Deleted settings for nonexistent project folders:', deletionFolders.map(folder => ' ' + folder));
        } else {
            console.log('All settings seem valid');
        }
    }

    static async _saveToFile(projectFolder, paramValues) {
        const paramValuesByFolder = await this._loadFromFile(undefined);
        if (paramValues !== null) {
            paramValuesByFolder[projectFolder] = paramValues;
            await this._saveAllSettingsToFile(paramValuesByFolder);
            DEBUG?.(`Saved project settings: ${JSON.stringify(paramValues)}`);
        } else {
            delete paramValuesByFolder[projectFolder];
            await this._saveAllSettingsToFile(paramValuesByFolder);
            console.log('Deleted project settings');
        }
    }

    static async _saveAllSettingsToFile(paramValuesByFolder) {
        DEBUG?.(`Saving all settings to ${CONFIG.paths.settings}`);
        await fs.promises.mkdir(path.dirname(CONFIG.paths.settings), { recursive: true })
        await fs.promises.writeFile(CONFIG.paths.settings, JSON.stringify(paramValuesByFolder, null, 2));
        DEBUG?.('Saved settings');
    }

    static async _saveAuthToFile(params, authValues) {
        const appUrl = params.get('appUrl');
        const location = `${TOKEN_STORAGE_DESC.plain} at ${CONFIG.paths.auth} for app URL ${appUrl}, subdomain ${params.get('subdomain')}`;
        const allAuthValues = await this._loadAuthFromFile(undefined, undefined);

        if (authValues !== null) {
            (allAuthValues[appUrl] || (allAuthValues[appUrl] = {}))[params.get('subdomain')] = authValues;
            await fs.promises.mkdir(path.dirname(CONFIG.paths.auth), { recursive: true })
            await fs.promises.writeFile(CONFIG.paths.auth, JSON.stringify(allAuthValues, null, 2));
            notifyLoggedIn(params)?.(`Saved authentication data to ${location}`);
        } else if (allAuthValues[appUrl]) {
            delete allAuthValues[appUrl][params.get('subdomain')];
            if (Object.keys(allAuthValues[appUrl]).length === 0) {
                delete allAuthValues[appUrl];
            }
            await fs.promises.mkdir(path.dirname(CONFIG.paths.auth), { recursive: true })
            await fs.promises.writeFile(CONFIG.paths.auth, JSON.stringify(allAuthValues, null, 2));
            console.log('Deleted authentication data from', location);
        } else {
            notifyLoggedIn(params)?.(`No authentication data to delete from ${location}`);
        }
    }

    static async _saveAuthToKeyring(params, auth) {
        if (!keytar) {
            return;
        }

        const location = `${TOKEN_STORAGE_DESC.keyring} for app URL ${params.get('appUrl')}, subdomain ${params.get('subdomain')}`;

        if (auth !== null) {
            await keytar.setPassword(MTX_FULLY_QUALIFIED, getKeyringAccountName(params), JSON.stringify(auth));
            notifyLoggedIn(params)?.(`Saved authentication data to ${location}`);
        } else {
            await keytar.deletePassword(MTX_FULLY_QUALIFIED, getKeyringAccountName(params));
            console.log('Deleted authentication data from', location);
        }
    }

    static async _loadFromFile(projectFolder) {
        const all = !projectFolder;

        if (!fs.existsSync(CONFIG.paths.settings)) {
            DEBUG?.('Settings file not found');
            return emptyData(all);
        }

        let settingsByFolder
        try {
            settingsByFolder = JSON.parse((await fs.promises.readFile(CONFIG.paths.settings)).toString());
        } catch (err) {
            DEBUG?.('Empty settings file');
            return emptyData(all);
        }

        if (all) { // return settings for all projects
            return settingsByFolder;
        }

        if (!settingsByFolder[projectFolder]) {
            DEBUG?.(`No settings found for project ${projectFolder}`);
            return new ParamCollection();
        }

        return new ParamCollection(settingsByFolder[projectFolder]);
    }

    static async _loadAuthFromFile(appUrl, subdomain) {
        const all = !appUrl;

        if (!fs.existsSync(CONFIG.paths.auth)) {
            DEBUG?.('Authentication-data file not found');
            return emptyData(all);
        }

        let allAuth
        try {
            allAuth = JSON.parse((await fs.promises.readFile(CONFIG.paths.auth)).toString());
        } catch (err) {
            DEBUG?.('Empty authentication-data file');
            return emptyData(all);
        }

        if (all) { // return auth data for all projects
            return allAuth;
        }

        if (!allAuth[appUrl]) {
            DEBUG?.(`File contains no authentication data for app URL ${appUrl}`);
            return new ParamCollection();
        }

        const authForSubdomain = allAuth[appUrl][subdomain];

        if (!authForSubdomain) {
            DEBUG?.(`File contains no authentication data for subdomain ${subdomain} (app URL: ${appUrl})`);
            return new ParamCollection();
        }

        if (authForSubdomain.token) {
            authForSubdomain.tokenStorage = 'plain';
        }

        return new ParamCollection(authForSubdomain);
    }

    static async _loadAuthFromKeyring(appUrl, subdomain) {
        if (!keytar) {
            return new ParamCollection();
        }

        const authString = await keytar.getPassword(MTX_FULLY_QUALIFIED, getKeyringAccountName(new ParamCollection({ appUrl, subdomain })));

        if (!authString) {
            DEBUG?.(`${capitalize(TOKEN_STORAGE_DESC.keyring)} contains no authentication data for URL ${appUrl} and subdomain '${subdomain}'`);
            return new ParamCollection();
        }

        let auth;

        try {
            auth = JSON.parse(authString);
        } catch (error) {
            auth = {};
        }

        if (auth.token) {
            auth.tokenStorage = 'keyring';
        }

        return new ParamCollection(auth);
    }

}

module.exports = {
    SettingsManager,
    other
};
