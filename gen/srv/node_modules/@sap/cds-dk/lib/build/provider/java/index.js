const fs = require('fs')
const path = require('path')
const cds = require('../../../cds')
const BuildTaskHandlerEdmx = require('../buildTaskHandlerEdmx')
const { OUTPUT_MODE, OUTPUT_MODE_RESULT, FILE_EXT_CDS, CONTENT_LANGUAGE_BUNDLES, CONTENT_DEFAULT_CSN, DEFAULT_CSN_FILE_NAME } = require('../../constants')
const { getI18nDefaultFolder } = require('../../util')
const DEFAULT_COMPILE_DEST_FOLDER = path.normalize('src/main/resources/edmx')

class JavaModuleBuilder extends BuildTaskHandlerEdmx {
    init() {
        super.init()
        this.task.options.compileDest = path.resolve(this.task.dest, this.task.options.compileDest || DEFAULT_COMPILE_DEST_FOLDER)
    }

    async build() {
        const { src, dest } = this.task

        const odataOptions = {
            version: cds.env.odata?.version
        }

        const model = await this.model()
        if (!model) {
            return
        }

        const odata = await this._compileForOdata(model, this.task.options.compileDest, odataOptions)
        await this.compileToEdmx(odata, this.task.options.compileDest, odataOptions)

        if (this.hasBuildOption(CONTENT_LANGUAGE_BUNDLES, true)) {
            // collect and write language bundles into single i18n.json file
            const i18n = await this.collectLanguageBundles(model, path.join(this.task.dest, getI18nDefaultFolder()))
            if (i18n && this.hasBuildOption(OUTPUT_MODE, OUTPUT_MODE_RESULT)) {
                this._result.languageBundles = i18n.bundles
            }
        }
        if (this.isStagingBuild() && this.hasBuildOption(OUTPUT_MODE, OUTPUT_MODE_RESULT)) {
            await this._copyNativeContent(src, dest)
        }
        return this._result
    }

    async clean() {
        if (this.isStagingBuild()) {
            return super.clean()
        }
        this.logger._debug && this.logger.debug(`Deleting build target folder ${this.task.options.compileDest}`)
        await fs.promises.rm(this.task.options.compileDest, { force: true, recursive: true })
    }

    async _copyNativeContent(src, dest) {
        return super.copyNativeContent(src, dest, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                return true // using common filter for folders
            } else {
                const extname = path.extname(entry)
                return extname !== FILE_EXT_CDS
            }
        })
    }

    async _compileForOdata(model, csnDest, compileOptions) {
        // csn for service providers
        const m = cds.compile.for.java(model, {
            ...this._options4odata(),
            ...compileOptions
        })
        const csnFile = path.join(csnDest, DEFAULT_CSN_FILE_NAME)
        let csnModel
        // adding csn to build result containing @source and _where persisted properties
        if (this.hasBuildOption(CONTENT_DEFAULT_CSN, true)) { //default true or undefined
            const csnStr = await this.compileToJson(model, csnFile)
            csnModel = JSON.parse(csnStr)
            csnModel.meta = model.meta
        } else {
            const csnStr = await this.compileToJson(m, csnFile)
            csnModel = JSON.parse(csnStr)
            csnModel.meta = m.meta
        }
        if (this.hasBuildOption(OUTPUT_MODE, OUTPUT_MODE_RESULT)) {
            this._result.csn = csnModel
        }

        return m
    }

    _isCompilerV1() {
        const version = cds.compiler.version()
        const match = version.match(/(\d+)\.?(\d*)\.?(\d*)/)
        return match && match[1] === 1
    }
}
module.exports = JavaModuleBuilder
