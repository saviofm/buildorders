const fs = require('fs')
const path = require('path')
const cds = require('../cds'), { _log:log } = cds
const BuildTaskProviderFactory = require('./buildTaskProviderFactory')
const { hasJavaNature, getProperty, redactCredentials, flatten, getDefaultModelOptions } = require('./util')
const { FILE_EXT_CDS, BUILD_TASK_JAVA_CF, BUILD_TASK_JAVA } = require("./constants")

class BuildTaskFactory {
    constructor(options) {
        this._providerFactory = new BuildTaskProviderFactory(options)
    }
    get providerFactory() {
        return this._providerFactory
    }
    get logger() {
        return this.providerFactory.logger
    }
    get buildOptions() {
        return this.providerFactory.buildOptions
    }

    // the following order for determining build tasks is used
    // 1. create from command line input, e.g. cds build/all --for hana --src db --model srv --dest db
    // 2. read using cds.env.build.tasks
    // 3. create from cds.env.folders config data
    async getTasks() {
        try {
            const tasks = await this._createTasks()

            // log build tasks
            this.logger.log(`the following build tasks will be executed`)
            let tasksOutput = "   {\n     \"build\": {\n       \"target\": \"" + cds.env.build.target + "\",\n       \"tasks\": ["
            for (let i = 0; i < tasks.length; i++) {
                tasksOutput += "\n         " + BuildTaskFactory._stringifyTask(tasks[i]) + (i + 1 < tasks.length ? "," : "")
            }
            tasksOutput += "\n       ]\n     }\n   }\n"
            this.logger.log(tasksOutput)

            // for testing purposes
            this.logger.debug("cds.env used for build:")
            this.logger._debug && this.logger.debug(redactCredentials(cds.env))

            // always resolve tasks for input validation
            const resolvedTasks = this.providerFactory.resolveTasks(tasks)
            if (this.buildOptions.resolve) {
                return resolvedTasks
            }
            return tasks
        } catch (e) {
            this.logger.log('')
            // cds CLI layer is doing the logging if invoked using CLI
            if (!this.buildOptions.cli) {
                log(e, { withStack: true, log: (message) => this.logger.log(message) })
            }
            throw e
        }
    }

    async _createTasks() {
        this.logger.debug(`determining build tasks for project [${cds.root}].`)

        // clearing model cache (details https://github.tools.sap/cap/cds/pull/181) is no longer required
        // because of changes https://github.tools.sap/cap/cds/pull/1121
        // cds.resolve.cache = {}

        let tasks = BuildTaskFactory._getExistingTasks()
        if (tasks.length === 0) {
            tasks = await this.providerFactory.lookupTasks()
        } else {
            // 1. apply default values including task.for and task.use and ensure that for all tasks a provider exists - throwing error otherwise
            await this.providerFactory.applyTaskDefaults(tasks)
            // ensure that dependencies get wired up before filtering
            await this.providerFactory.lookupTasks(tasks)
        }

        // 3. filters the list of build tasks and adapts according to given CLI options
        // Note: A new task might get created, e.g. 'cds build --for hana' will enforce a hana build even if sqlite has been configured
        let existingTasks = tasks
        tasks = this._applyCliOptionsFilter(tasks)
        if (tasks.length === 0) {
            return tasks
        }
        // a new array is returned to indicate new build tasks have been created
        if (tasks !== existingTasks) {
            // a different task shall be executed
            await this.providerFactory.applyTaskDefaults(tasks)
        }

        // 2. add dependencies
        existingTasks = [...tasks]
        await this.providerFactory.lookupTasks(tasks)
        if (tasks.length > existingTasks.length) {
            const newTasks = tasks.filter(task => !existingTasks.includes(task))
            // a dependant task was added
            this._applyCliOptions(newTasks)
        }

        // obligatory task defaults shared by all tasks
        BuildTaskFactory._applyCommonTaskDefaults(tasks)

        // ensure correct values for optional build task properties, error for missing mandatory properties
        BuildTaskFactory._validateBuildTasks(tasks)

        this._setDefaultBuildTargetFolder(tasks)
        return tasks
    }

    static _getExistingTasks() {
        return Array.isArray(getProperty(cds.env, 'build.tasks')) ? JSON.parse(JSON.stringify(cds.env.build.tasks)) : []
    }

    static _applyCommonTaskDefaults(tasks) {
        const modelPaths = getDefaultModelOptions()

        tasks.forEach(task => {
            this._setTaskModelOptions(task, modelPaths)
            if (!task.src) {
                throw new Error(`Invalid build task definition - value of property 'src' is missing in [${task.for || task.use}].`)
            }
        })
    }

    static _validateBuildTasks(tasks) {
        tasks.forEach(task => {
            if (!task.src) {
                throw new Error(`Invalid build task definition - value of property 'src' is missing in [${task.for || task.use}].`)
            }
        })
    }

    _setDefaultBuildTargetFolder(tasks) {
        const task = tasks.find(task => task.for === BUILD_TASK_JAVA_CF || task.for === BUILD_TASK_JAVA)
        const srv = task ? task.src : BuildTaskFactory._getModuleFolder(flatten([cds.env.folders.srv])) || "srv"

        // Java projects use "." as the default build target folder
        if (hasJavaNature([path.join(cds.root, srv), cds.root]) && BuildTaskFactory._adaptBuildTargetSettingForJava()) {
            this.logger.debug("using inplace build for java project instead of default staging build")
        }
    }

    /**
    * Use inplace build for java projects if build.target has not been configured.
    * @returns {boolean} true if changed, false otherwise
    */
    static _adaptBuildTargetSettingForJava() {
        if (cds.env.build.target !== ".") {
            // filter user settings of cds.env
            const userEnv = cds.env.for("cds", cds.root, false)

            // use helper as env.build might be undefined
            if (!userEnv.build?.target) {
                cds.env.build.target = "."
                return true
            }
        }
        return false
    }

    _applyCliOptionsFilter(tasks) {
        const buildOptions = this.buildOptions
        // filter tasks using either option for, use, src
        let resultTasks = tasks.filter(task => {
            return (!buildOptions.use || buildOptions.use === task.use)
                && (!buildOptions.for || buildOptions.for === task.for)
                && (!buildOptions.src || buildOptions.src === task.src)
        })
        if (resultTasks.length === 0) {
            if (buildOptions.for || buildOptions.use) {
                const task = {}
                if ((buildOptions.for)) {
                    task.for = buildOptions.for
                }
                if ((buildOptions.use)) {
                    task.use = buildOptions.use
                }
                if (buildOptions.src) {
                    task.src = buildOptions.src
                }
                resultTasks.push(task)
            }
        } else if (resultTasks.length < tasks.length) {
            // return the same array as long as it contains a subset of the given tasks
            tasks.length = 0
            resultTasks.forEach(task => tasks.push(task))
            resultTasks = tasks
        }
        this._applyCliOptions(resultTasks)
        return resultTasks
    }

    _applyCliOptions(tasks) {
        const buildOptions = this.buildOptions
        // apply remaining cli options to filtered tasks
        tasks.forEach(task => {
            if (buildOptions.dest) {
                task.dest = buildOptions.dest
            }
            if (buildOptions.opts) {
                const opts = BuildTaskFactory._scanTaskOptionParams(buildOptions.opts)
                task.options = task.options ? Object.assign(task.options, opts) : opts
            }
        })
    }

    static _setTaskModelOptions(task, defaultModelPaths) {
        task.options = task.options || {}
        if (!task.options.model || Array.isArray(task.options.model) && task.options.model.length === 0) {
            defaultModelPaths = new Set(defaultModelPaths)
            if (task.src) {
                defaultModelPaths.add(task.src)
            }
            task.options.model = [...defaultModelPaths]
        } else if (!Array.isArray(task.options.model)) {
            task.options.model = [task.options.model]
        }
    }

    static _stringifyTask(task) {
        // ensures identical order of properties
        const order = ["for", "use", "src", "dest", "options"]
        const keys = Object.keys(task).sort((a, b) => order.indexOf(a) - order.indexOf(b))

        return keys.reduce((acc, key, idx) => {
            // render either "for" OR "use" value
            return acc + (!key.match("^_") ? (key !== "use" || keys[idx - 1] !== "for" ? (acc !== "{" ? ", " : "") + JSON.stringify(key) + ":" + JSON.stringify(task[key]) : "") : "")
        }, "{") + "}"
    }

    static _scanTaskOptionParams(optsParams) {
        // need to create new regex every call since a constant would keep the match state
        const quoteRegex = /([\w-]+)=([\w/.]+|\[([\w/,.]+)\])/g

        // captures a=1             => a:1
        //          a=[x,y,z]       => a:[x,y,z]
        //          a=1,b=[x,y,z]   => a:1 b=[x,y,z]
        let match = quoteRegex.exec(optsParams)
        const taskOptions = {}

        while (match != null) {
            const key = match[1]
            const value = match[3] || match[2]
            const valueArray = value.split(",")
            taskOptions[key] = valueArray.length > 1 ? valueArray.map((entry) => entry.trim()) : value
            match = quoteRegex.exec(optsParams)
        }
        return taskOptions
    }

    /**
     * For valid paths remove trailing '/'. Otherwise return as is - important!!
     * @param {*} dir
     */
    static _normalizePath(dir) {
        return typeof dir === "string" ? dir.replace(/\/$/, '') : dir
    }

    /**
     * Determines the module folder from the past list that may represent files or folders w or w/o .cds file extension.
     * @param {Array} filesOrFolders
     */
    static _getModuleFolder(filesOrFolders) {
        const resources = [...filesOrFolders]
        filesOrFolders.forEach(fileOrFolder => {
            if (path.extname(fileOrFolder) !== FILE_EXT_CDS) {
                resources.push(fileOrFolder + FILE_EXT_CDS)
            }
        })
        return resources.reduce((acc, resource) => {
            if (!acc) {
                let resourcePath = path.resolve(cds.root, resource)
                if (fs.existsSync(resourcePath)) {
                    if (fs.lstatSync(resourcePath).isDirectory()) {
                        acc = resource
                    } else {
                        // represents file
                        acc = path.dirname(resource)
                    }
                }
            }
            return acc
        }, null)
    }
}
module.exports = BuildTaskFactory
