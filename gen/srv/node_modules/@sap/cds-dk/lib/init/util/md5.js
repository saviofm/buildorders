const cds = require('../../cds')
const { exists, mkdirp, isdir, readdir, read, write, copy, path } = cds.utils;
const { dirname, join } = path

const crypto = require('crypto');
const os = require('os');
const { copyRenderedYAML } = require('../../util/fs');

async function copyAndTrack(source, dest, context = {}, { force = false, project } = {}) {
    await mkdirp(dirname(dest));
    if (isdir(source)) {
        const dirents = await readdir(source);
        return Promise.all(dirents.map(each => copyAndTrack(join(source, each), join(dest, each), context)))
    } else {
        const data = exists(source) ? await read(source, 'utf-8') : undefined
        if (!force && await _isChartFileModified(dest, context)) {
            console.log('Chart file ' + dest + ' has been modified and will not be updated.');
        } else {
            _track(dest, data, context);
            if (project) return copyRenderedYAML(source, dest, project)
            return copy(source).to(dest);
        }
    }
}


/**
* Takes path of md5 file as an argument and returns a JSON object containing hashes of files stored in MD5 file.
* @param {String} file
* @returns {Promise<JSON>}
*/
async function parseMd5File(file) {
    const md5 = exists(file) ? await read(file) : undefined
    if (!md5) return {}
    return Object.fromEntries(md5.split(os.EOL).map(line => line.split(' ').reverse()))
}

/**
* Takes json object containing key as filename and value as MD5 hash and generates a md5sum format file.
* @param {String} file
* @param {Promise<JSON>} data
*/
async function writeMd5File(file, data) {
    await write(Object.entries(data).map(([filename, hash]) =>
        `${hash} ${filename}` + os.EOL
    ).join('')).to(file)
}


// REVISIT: Why pass entire 'context' if we're only interested in one key in the old tracking data? -> decrease coupling
async function _isChartFileModified(file, context = {}) {
    const data = exists(file) ? await read(file, 'utf-8') : undefined
    if (!data) return false;
    const key = _pathKey(join(cds.root, 'chart'), file);
    const hashedContent = _hash(data);
    return context.newTrackingData[key] ? context.newTrackingData[key] !== hashedContent : context.oldTrackingData?.[key] !== hashedContent;
}

function _hash(data) {
    return crypto.createHash('md5').update(data).digest('base64');
}

function _pathKey(basePath, cPath) {
    return path.posix.normalize(_toPosix(path.relative(basePath, cPath)))
}

function _toPosix(path) {
    return path.replace(/\\/g, '/');
}

// REVISIT: Replace inout parameter 'context' by return value of new tracking data
async function _track(filePath, data, context = {}) {
    const key = _pathKey(path.join(cds.root, 'chart'), filePath);
    const hashedContent = _hash(data);
    if (context.oldTrackingData != undefined && context.oldTrackingData[key] != undefined) {
        context.oldTrackingData[key] = hashedContent;
    }
    context.newTrackingData[key] = hashedContent;
}

// REVISIT: Can we make copyAndTrack the only public API?
module.exports = {
    copyAndTrack,
    parseMd5File,
    writeMd5File
}
