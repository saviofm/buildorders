const cds = require('../../cds')
const { path, read, exists } = cds.utils
const { parseXml } = require('./xml')
const P_LANGUAGE_JAVA = 'java'
const P_LANGUAGE_NODEJS = 'nodejs'
const DEFAULT_P_LANGUAGE = P_LANGUAGE_NODEJS
const DEBUG = /\b(y|all|cli)\b/.test(process.env.DEBUG) && console.debug

module.exports = new class ProjectReader {

    constructor() {
        this.readProject = this.readProject.bind(this)
    }

    // REVISIT: There should be a better (and parallelizable) API provided by cds.env
    /**
     * Returns cds.env using 'production' profile by default as mta deployment is executed with having production profile set.
     */
    getEnv(profile = 'production') {
        const cdsEnvVar = process.env.CDS_ENV
        process.env.CDS_ENV = profile
        try {
            // REVISIT: this is invoked 5 times for cds add multitenancy
            return cds.env.for('cds')
        } finally {
            cdsEnvVar ? process.env.CDS_ENV = cdsEnvVar : delete process.env.CDS_ENV
        }
    }

    async readProject(options) {
        // if (options?.cwd) cds.root = options.cwd

        const env = this.getEnv()
        DEBUG && DEBUG({ env })

        const _hasFacet = template => require(`../template/${template}`).hasFacet(env, options)
        const project = {
            profile: options?.for,
            language: DEFAULT_P_LANGUAGE,
            srv: {},
            db: [],
            requires: [],
            get hasRequires()    { return this.requires.length > 0 },
            get needsSidecar()   { return (options?.add.has('hana') || this.db.length > 0) && (this.isJava || !this.isMultitenant) },
            get configFile()     { return exists('pom.xml') ? '.cdsrc.json' : 'package.json' },
            get isNodejs()       { return _hasFacet('nodejs') },
            get isJava()         { return _hasFacet('java') },
            get hasSidecar()     { return exists('mtx', 'sidecar') },
            get isMultitenant()  { return _hasFacet('multitenancy') },
            get isExtensible()   { return _hasFacet('extensibility') },
            get hasHana()        { return _hasFacet('hana') },
            get hasXsuaa()       { return _hasFacet('xsuaa') },
            get hasAuditlog()    { return _hasFacet('auditlog') },
            get hasApprouter()   { return _hasFacet('approuter') },
            get hasDestination() { return _hasFacet('destination') },
            get hasHtml5Repo()   { return _hasFacet('html5-repo') },
            get hasMta()         { return _hasFacet('mta') },
            get hasHelm()        { return _hasFacet('helm') },
            get appPath()        { return env.folders.app ?? 'app' },
        }

        // setting the effective env as it might have changed by already executed 'add' commands, e.g. cds init foo --add hana,mta
        const cds = require('../../cds')
        cds.env // make sure env is initialized, otherwise we cannot set it (exotic case)
        cds.env = env

        // check whether we have a hana service binding defined as a hana build task is returned by default for compatibility reasons if neither hana, nor sqlite has been defined
        if (env?.requires?.db?.kind === 'hana') {
            const dbFolder = env.folders.db.replace(/\/$/, '')
            const relDbDestPath = path.join(env.build.target, dbFolder).replace(/\\/g, '/')
            project.db.push({ path: relDbDestPath, name: dbFolder })
        }

        const srvFolder = env.folders.srv.replace(/\/$/, '')
        const relSrvDestPath = path.join(env.build.target, srvFolder).replace(/\\/g, '/')
        project.srvPath = relSrvDestPath
        project.srvName = srvFolder

        if (env['project-nature'] === 'java') {
            project.language = P_LANGUAGE_JAVA
            project.srvExt = await this._getJavaExtDescriptor(path.resolve(cds.root, srvFolder))
        }

        // setting app name, app description...
        await this._setAppDetails(project)

        // setting required resource information
        this._setResourceDependencies(env, project)

        DEBUG && DEBUG({ project })
        return project
    }

    /**
     * Determines java specific properties for the given module source path.
     * @param {object} srcPath
     */
    async _getJavaExtDescriptor(srcPath) {
        // by default spring-boot:repackage is used creating an executable jar archive
        const pom = await parseXml(path.join(srcPath, 'pom.xml'))
        if (pom) {
            const dependencies = pom?.dependencies?.[0]?.dependency
            const isOldJavaRuntime = [...dependencies].some(d => /com\.sap\.cloud\.servicesdk/.test(d?.groupId?.[0]))
            if (isOldJavaRuntime) {
                throw "Projects using the classic CAP Java SDK are not supported"
            }

            const descriptor = { archiveName: path.basename(cds.root) + "-exec.jar" }
            const archiveName = pom?.artifactId?.[0]
            const suffix = pom?.packaging?.[0]
            if (archiveName) descriptor.archiveName = archiveName + '-exec.' + suffix
            return descriptor
        }
    }

    async _setAppDetails(cap) {
        if (cap.language !== P_LANGUAGE_JAVA && cap.language !== P_LANGUAGE_NODEJS) {
            throw Error(`${cap.language} not supported`)
        }

        // Use either pom.xml or package.json
        if (exists('pom.xml')) {
            const pom = await parseXml('pom.xml')
            const [artifactId] = pom?.artifactId ?? []
            const [description] = pom?.description ?? []
            let [version] = pom?.version ?? []
            // might need to resolve <version>${revision}</version> property
            if (version === '${revision}') {
                version = pom?.properties?.[0].revision[0]
            }
            if (version) {
                // check compliance with mta version format - copied from mbt build error message
                // if not compliant we use a static default value, see below...
                if (/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(-(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(\.(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\+[0-9a-zA-Z-]+(\.[0-9a-zA-Z-]+)*)?$/.test(version)) {
                    cap.appVersion = version
                }
            }
            if (artifactId) {
                cap.appName = artifactId.split(/-parent/)[0]
            }
            if (description) {
                cap.appDescription = description
            }
        }
        else if (exists('package.json')) {
            const { name, version, description } = await read('package.json')
            cap.appDescription = cap.appDescription ?? description
            cap.appVersion = cap.appVersion ?? version
            if (name) {
                const segments = name.trim().replace(/@/g, '').split('/').map(encodeURIComponent)
                cap.appName = cap.appName ?? segments[segments.length - 1]
                cap.appId = cap.appId ?? segments.join('.')
                cap.appDescription = cap.appDescription ?? cap.appName
            }
        }

        // 2. use project name and static default values
        cap.appName = cap.appName ?? path.basename(cds.root)
        cap.appDescription = cap.appDescription ?? cap.appName + " application"
        cap.appId = cap.appId ?? cap.appName
        cap.appVersion = cap.appVersion ?? '1.0.0'
    }

    // REVISIT: Only used for orphaned cds add cf-manifest. Still needed?
    _setResourceDependencies(env, cap) {
        for (const [key, require] of Object.entries(env.requires)) {
            if (key === 'sql' || key === 'sqlite' || key === 'hana') continue // ignore abstract helper definitions like sql
            const resource = this._getReqResource(key, require, cap)
            if (resource) cap.requires.push({ resource }) // using production profile
        }
    }

    _getReqResource(key, reqEntry, cap) {
        const { kind, dialect, use, vcap = {}, multiTenant } = reqEntry
        const { appName, isMultitenant } = cap
        const resource = {
            name: !key.includes(appName) ? `${appName}-${key}` : key,
            service: '',
            vcap,
            get isMultitenant() { return isMultitenant || multiTenant || false },
            get isManagedHana() { return this.vcap.label === 'service-manager' || this.service === 'service-manager' },
            get isPlainHana()   { return this.service === 'hana' && !this.isManagedHana },
            get isHana()        { return this.isPlainHana || this.isManagedHana },
            get isXsuaa()       { return this.service === 'xsuaa' },
        }

        switch (kind) {
            case 'sql':
            case 'hana':
                if (kind === 'sql' && dialect !== 'hana' && use !== 'hana') {
                    break
                }
                // use different service name to avoid conflicts when switching from single tenant to multitenant
                // otherwise we would enforce that users have to delete the db container first
                if (resource.isMultitenant) {
                    resource.service = 'service-manager'
                    resource.vcap.plan = 'container'
                } else {
                    resource.service = 'hana'
                    resource.vcap.plan = 'hdi-shared'
                }
                break

            case 'xsuaa':
                resource.service = kind
                resource.vcap.plan = 'application'
                break
            default: {
                vcap.plan ? resource.service = kind : DEBUG && DEBUG(`Skip resource ${key}`)
            }
        }
        return resource.service ? resource : null
    }
}
