const YAML = require('@sap/cds-foss').yaml
const { copy, read, write, exists } = require('../../cds').utils
const { readYAML, writeYAML, readJSON } = require('../../util/fs')
const { EOL } = require('node:os')


function _isObject(item) {
  return item && typeof item === 'object' && !Array.isArray(item)
}

function _deepMerge(target, source) {
  const unique = array => [...new Set(array.map(JSON.stringify))].map(JSON.parse)
  if (_isObject(target) && _isObject(source)) {
      for (const key in source) {
          if (_isObject(source[key])) {
              if (!target[key]) Object.assign(target, { [key]: source[key] })
              else _deepMerge(target[key], source[key])
          } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {
              target[key] = unique([...source[key], ...target[key]])
          } else {
              Object.assign(target, { [key]: target[key] || source[key] })
          }
      }
  } else if (Array.isArray(target) && Array.isArray(source)) {
      target = unique([...source, ...target])
  }
  return target ?? source
}

async function sort(path, key) {
  const json = await read(path)
  json[key] = Object.fromEntries(
      Object.entries(json[key]).sort(([a],[b]) => a>b ? 1 : -1)
  )
  await write(path, json, { spaces: 2 });
}

/**
 * @param {string} into - file path to merge into
 * @param {string | string[]} from - either path to file (string) or lines from source gitignore (string[])
 * @returns {Promise<string[]>} the lines of the updated .gitignore
 */
async function mergeGitignore (into, from) {
    const source = typeof from === 'string' ? (await read(from)).split(EOL) : from

    if (typeof into === 'string' && !exists(into)) {
      return write(into, source.join(EOL))
    }

    const target = (await read(into)).split(EOL)
    const enhanced = target.concat(source.filter(line => !target.includes(line)))
    await write(into, enhanced.join(EOL))
    return enhanced
  }

async function mergeJSON(into, from, project, semantics) {
    const source = typeof from === 'string' ? await readJSON(from, project) : from

    if (typeof into === 'string' && !exists(into)) {
        return write(into, source, { spaces: 2 })
    }

    let result
    if (semantics) {
        const target = await read(into)
        const targetYAML = YAML.parseDocument(YAML.stringify(target))
        const sourceYAML = YAML.parseDocument(YAML.stringify(source))
        const resultYAML = await mergeYAML(targetYAML, sourceYAML, project, semantics)
        result = YAML.parse(YAML.stringify(resultYAML))
    } else {
        const target = typeof into === 'string' ? await read(into) : into
        result = _deepMerge(target, source)
    }
    if (typeof into === 'string') await write(into, result, { spaces: 2 })
    return result
}

async function mergeYAML(into, from, project, semantics = {}) {
    const target = typeof into === 'string' ? await readYAML(into) : into instanceof YAML.Document ? into : new YAML.Document(into)
    const source = typeof from === 'string' ? await readYAML(from, project) : from instanceof YAML.Document ? from : new YAML.Document(from)

    if (!target || !target.contents) {
        if (typeof into === 'string' && typeof from === 'string') {
            return project ? writeYAML(into, source) : copy(from, into)
        }
        return /* has no YAML */
    }

    const entryMap = new Map, templateEntryMap = new Map()

    const { additions, overwrites, deletions, relationships } = semantics
    additions?.forEach(entry => {
        entryMap.set(entry, undefined)
        templateEntryMap.set(entry, undefined)
    })
    deletions?.forEach(deletion => {
        entryMap.set(deletion.item, undefined)
    })
    relationships?.forEach(relationship => {
        const [entry] = relationship.into
        const [insertEntry] = relationship.insert
        const hash = insertEntry + ' -> ' + entry
        entryMap.set(hash, undefined)
    })

    let collectionStack = [target.contents]

    const _getProperty = (object, keyPath) => keyPath.split('.').reduce((p, k) => p && p[k], object)
    const _getYAMLProperty = (object, keyPath) => keyPath.split('.').reduce((p, k) => p && p.get(k), object)

    const _validateWhere = (node, dict, index) => {
        const _addToMap = entries => entries?.filter(entry => {
                let where = entry.in
                if (typeof where === 'string') return true // just a key path on the document root
                else where = where[0] // a more complex list of constraints, a sequence/array is involved
                const neededParent = dict.get(where)?.node
                return collectionStack.includes(neededParent) // lookbehind in parent collection stack
                // REVISIT: Only look behind until sequence is reached?
        }).forEach(item => {
            const json = JSON.parse(String(node))
            const whereFulfilled = item.where.every(constraint =>
                constraint.isEqualTo === _getProperty(json, constraint.property)
            )
            if (whereFulfilled) {
                const [collection] = collectionStack
                dict.set(item, { json, node, index, collection })
            }
        })
        if (additions) _addToMap(additions)
        if (deletions) _addToMap(deletions.map(deletion => deletion.item))
        if (relationships) _addToMap(relationships?.map(({into: [entry]}) => entry).filter(e => e))
    }

    function _traverseYAMLNode(node, index, actions, templateNode) {
        let shifted = false
        if (YAML.isMap(node)) {
            actions.visitMap?.(node, index)
            const [collection] = collectionStack
            if (YAML.isSeq(collection)) {
                collectionStack.unshift(node)
                shifted = true
            }
        } else if (YAML.isPair(node) && node.value?.items) {
            collectionStack.unshift(node.value)
        } else if (YAML.isScalar(node) && semantics.forceOverwrite && templateNode) {
            node.value = templateNode.value ?? templateNode.items?.[0]?.value?.value
        }

        if (node.items) {
            if (YAML.isSeq(node) && templateNode?.items) {
                actions?.mergeCollection && actions.mergeCollection(node, templateNode)
                _traverseYAMLCollection(node, actions, templateNode)
            } else {
                _traverseYAMLCollection(node, actions, templateNode)
            }
        } else if (node.value?.items || node.value && semantics.forceOverwrite) {
            _traverseYAMLNode(node.value, index, actions, templateNode?.value)
        }

        if (node.value?.items || shifted) {
            collectionStack.shift()
        }
    }
    _traverseYAMLNode.bind(this)

    function _traverseYAMLCollection (collection, actions, templateCollection) {
        if (!collection) return

        const keyToIndex = new Map, templateIndexToIndex = new Map

        // Map collection items to their semantic counterpart(s)
        collection.items.forEach((node, i) => {
            if (node.key) keyToIndex.set(node.key.value, i)
            const entry = [...entryMap.entries()].find(([,value]) => value?.node === node)
            if (entry) {
                const [entryKey] = entry
                const templateEntry = entryKey && templateEntryMap.get(entryKey)
                const templateIndex = templateEntry?.index
                if (templateIndex !== undefined) templateIndexToIndex.set(templateIndex, i)
            }
            if (!templateCollection) _traverseYAMLNode(node, i, actions)
        })

        if (!templateCollection) return

        templateCollection.items.forEach((templateNode, templateIndex) => {
            if (YAML.isScalar(templateNode)) {
                if (!collection.items.map(item => item.value).includes(templateNode.value)) {
                    collection.add(templateNode)
                }
            } else if (YAML.isPair(templateNode)) {
                const i = keyToIndex.get(templateNode.key.value)
                const [collection] = collectionStack
                const targetNode = collection.items?.[i]
                if (targetNode) {
                    _traverseYAMLNode(targetNode, templateIndex, actions, templateNode)
                } else if (actions.mergePair) {
                    actions.mergePair(collection, templateNode)
                }
            } else if (YAML.isMap(templateNode)) {
                const targetNode = collection.items[templateIndexToIndex.get(templateIndex)]
                if (actions.mergeCollection) actions.mergeCollection(targetNode, templateNode)
                if (targetNode) {
                    _traverseYAMLNode(targetNode, templateIndex, actions, templateNode)
                }
            }
        })
    }
    _traverseYAMLCollection.bind(this)

    // 1. Register the entries in the template
    _traverseYAMLNode(source.contents, null, {
        visitMap: (node, index) => _validateWhere(node, templateEntryMap, index)
    })

    // 2. Register the entries in the project
    _traverseYAMLNode(target.contents, null, {
        visitMap: (node, index) => _validateWhere(node, entryMap, index)
    })

    // 3. Apply overwrites to already found entries
    overwrites?.forEach(({ item, withValue }) => {
        const keyPath = Array.isArray(item) && typeof item[0] === 'string' ? item[0] : typeof item === 'string' ? item : item[1]
        const inEntry = Array.isArray(item) && typeof item[0] === 'object' ? item[0] : typeof item === 'object' ? item : item[1]
        const node = inEntry && entryMap.get(inEntry) ? entryMap.get(inEntry).node : collectionStack[collectionStack.length - 1]
        const keys = keyPath.split('.')
        if (!node.getIn(keys)) return
        _getYAMLProperty(node, keys.slice(0, keys.length - 1).join('.'))
            .set(keys[keys.length - 1], withValue)
    })

    // 4. Delete entries from the project (e.g. separate deployer module when adding mtx)
    deletions?.forEach(({ item, relationships }) => {
        const entry = entryMap.get(item)
        if (!entry) return
        entry.collection.delete(entry.index)

        relationships?.forEach(relationship => {
            const [allWithinKeyPath, inKeyPath, into] = relationship.allWithin
            const parent = _getYAMLProperty(target, allWithinKeyPath)
            for (const child of parent.items) {
                const grandchild = _getYAMLProperty(child, inKeyPath)
                const i = grandchild?.items?.findIndex(node =>
                    node.get(into) === _getProperty(entry.json, relationship.removeProperty)
                ) ?? - 1
                if (i > -1) grandchild.delete(i)
            }
        })
    })

    // 5. Create missing entries and pairs
    _traverseYAMLNode(target.contents, null, {
        mergePair: (collection, templateNode) => {
            if (YAML.isMap(collection)) {
                collection.add(templateNode)
            }
        },
        mergeCollection: (targetNode, templateNode) => {
            if (YAML.isSeq(templateNode)) {
                let [,parent] = collectionStack
                additions?.filter(addition => {
                        if (typeof addition.in === 'string' || Array.isArray(addition.in) && typeof addition.in[0] === 'string') return true
                        const inEntry = Array.isArray(addition.in) ? entryMap.get(addition.in[0]) : entryMap.get(addition.in)
                        return inEntry?.node === parent
                    })
                    .filter(addition => {
                        const keyPath = typeof addition.in === 'string' ? addition.in : Array.isArray(addition.in) && typeof addition.in[0] === 'string' ? addition.in[0] : addition.in[1]
                        const keys = keyPath.split('.')
                        if (keys.length > collectionStack.length + 1) return
                        if (keys.length > 1) parent = collectionStack[keys.length]
                        return _getYAMLProperty(parent, keyPath) === targetNode
                    })
                    .filter(item => !entryMap.get(item))
                    .forEach(item => {
                        const templateNode = templateEntryMap.get(item).node
                        item.at !== undefined ? targetNode.items.splice(item.at, 0, templateNode) : targetNode.add(templateNode)
                    })
            }
        },
    }, source.contents)

    // 6. Re-register the entries in the project
    _traverseYAMLNode(target.contents, null, {
        visitMap: (node, index) => _validateWhere(node, entryMap, index)
    })

    // 7. Create missing relationships
    _traverseYAMLNode(target.contents, null, {
        mergeCollection: (targetNode, templateNode) => {
            if (YAML.isSeq(templateNode)) {
                const targetJSON = YAML.parse(String(targetNode))
                const relationship = semantics.relationships?.filter(r => r)
                    .find(relationship => {
                        const [entry, keyPath] = relationship.into
                        if (!entryMap.get(entry)) return false
                        const existingNode = _getYAMLProperty(entryMap.get(entry).node, keyPath)
                        return targetNode === existingNode
                })
                if (!relationship) return

                const intoKey = relationship.into[relationship.into.length - 1]
                const [entry, entryKeyPath] = relationship.insert
                const missingPairs = [entry]
                    .filter(item =>
                        !targetJSON.some(targetItem =>
                            _getProperty(entryMap.get(item).json, entryKeyPath) === targetItem[intoKey]
                        )
                    )
                    .map(item => entryMap.get(item).node.get(intoKey))
                missingPairs.forEach(pair => {
                    targetNode.add({ [intoKey]: pair })
                })
            }
        }
    }, source.contents)

    typeof into === 'string' && await writeYAML(into, target)
    return target
}

async function removeFromYAML(name, keyPaths) {
    const yaml = await readYAML(name)
    for (const keyPath of keyPaths) {
        let node = yaml
        const keys = keyPath.split('.')
        for (const [index, key] of keys.entries()) {
            if (index === keys.length - 1) {
                node.delete(key)
            } else {
                node = node.get(key)
            }
        }
    }
    await writeYAML(name, yaml)
}

async function removeFromYAMLArray(name, keyPath, aliasToRemove) {
    const yaml = await readYAML(name)

    let node = yaml
    // traverse to the array node
    const keys = keyPath.split('.')
    for (const key of keys) {
        node = node.get(key)
    }

    // find index of array entry with aliasToRemove entry
    let index = 0;
    let entryNode = node.getIn([index])
    while(entryNode !== undefined) {
        if(entryNode.toJSON().alias === aliasToRemove) {
            node.deleteIn([index])
            break;
        }
        index++;
        entryNode = node.getIn([index])
    }

    await writeYAML(name, yaml)
}

module.exports = {
  sort,
  mergeGitignore,
  mergeJSON,
  mergeYAML,
  removeFromYAML,
  removeFromYAMLArray
}
