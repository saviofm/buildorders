
const cds = require('../../../cds')
const { exists, fs } = cds.utils
const { resolve, join, relative }  = require('path');
const LOG = console
const DEBUG = cds.debug('cli')

module.exports = class DataTemplate extends require('../templateBase') {

  async run() {
    if (this.options['for']) {
      throw `\nError: Did you mean \`... --data:for\` ?`
    }

    const env = await this.getEnv();

    let dest = (typeof this.options.out === 'string') // target folder
      ? this.options.out
      : getDefaultTargetFolder(env);
    dest = resolve(cds.root, dest);

    const nameFilter = asRegex(this.options['data:for'])
    const force = this.options.force;

    let csn = await cds.compile.to.csn(cds.env.roots) // normal CSN

    // Skip of unused reuse entities like Language, Country, Currency
    csn = cds.minify(csn)

    // Also include 'external' entities w/ cds.persistence.skip (similar to 'mocked' option of serve).
    // Could be too much sometimes, but don't want to bother users w/ a separate option for this.
    includeExternalEntities(csn)

    csn = cds.compile.for.sql(csn, { names:env.sql.names, messages:[] })  // CSN w/ persistence information
    csn = cds.reflect(csn); // reflected model (adds additional helper functions)

    csn.all('entity')
      .filter (e => e.name.match(nameFilter)) // --for prefix|regex
      .filter (e => !e.query) // exclude entities with queries (projection on, select from ...)
      .filter (e => e.name !== 'DRAFT.DraftAdministrativeData' && !e.name.endsWith('.drafts')) // exclude draft stuff
      .forEach(e => processEntity(e, dest, csn, force));
  }
}

function includeExternalEntities(model) {
  for (let each in model.definitions) {
    const def = model.definitions[each]
    if (def['@cds.persistence.skip'] === true) {
      DEBUG?.('Including skipped entity '+each)
      delete def['@cds.persistence.skip']
    }
  }
  return model
}

function asRegex(spec) {
  if (typeof spec === 'string') {
    try {
      if (spec.match(/[\^$|*]/))
        return new RegExp(spec)
      else { // no meta chars -> prefix semantics
        spec = spec.replace(/\./g, '\\.') // escape dot
        return new RegExp('^'+spec+'.*')
      }
    } catch (err) {
      throw err.message // user error, so cut off stack trace
    }
  }
  return /.*/
}

function processEntity (entity, dest, csn, force) {
  let dataFileName;
  const namespace = getNamespace(csn, entity.name);
  if (!namespace || namespace == entity.name) {
    dataFileName = `${entity.name}.csv`;
  }
  else {
    const entityName = entity.name.replace(namespace + '.', '');
    dataFileName = `${namespace}-${entityName}.csv`;
  }

  if (entity.name.endsWith('.texts')) {
    // handle '.texts' entities (for localized elements) differently:
    // if there is already file exist with '_texts' (old cds versions) - overwrite this one (when --force is used)
    // otherwise use the new '.texts' format
    const dataFileNameOldFormat = dataFileName.replace('.texts.csv','_texts.csv');
    const dataFilePathOldFormat = join(dest, dataFileNameOldFormat);
    if (exists(dataFilePathOldFormat)) {
      createDataFile(true, dataFilePathOldFormat, dest, force, entity);
      return;
    }
  }

  const dataFilePath = join(dest, dataFileName);
  createDataFile(exists(dataFilePath), dataFilePath, dest, force, entity);
}

function getDefaultTargetFolder (env) {
  const { db } = env.folders
  // csv files should be located in the 'db/data' folder unless a 'db/csv' folder already exists
  return join(db, exists(join(db, 'csv')) ? 'csv' : 'data')
}


function createDataFile (isFileExists, dataFilePath, dest, force, entity) {
  let relFilePath = dataFilePath;
  if (dataFilePath.indexOf(cds.root) === 0) {
    // use relative path in log (for readability), only when data files are added within the project
    // (potentially can be located anywhere using the --out parameter)
    relFilePath = relative(cds.root, dataFilePath);
  }
  if (isFileExists && !force) {
    LOG.info(`Skipping ${relFilePath}`);
  }
  else {
    // continue only if file not already exists, or '--force' option provided
    const dataFileContent = prepareDataFileContent(entity);
    if (dataFileContent && dataFileContent.length) {
      if (!exists(dest))  fs.mkdirSync(dest, {recursive: true})
      fs.writeFileSync(dataFilePath, dataFileContent);
      isFileExists ? LOG.info(`Overwriting `+relFilePath) : LOG.info(`Creating `+relFilePath)
    }
  }
}

function prepareDataFileContent (entity) {
  const persistenceKeyNames = Object.keys(entity.keys||[])
  return Object.entries(entity.elements)
    .filter(([,element]) => !(element instanceof cds.Association)) // exclude associations+compositions
    .filter(([,element]) => !!element['@cds.persistence.name']) // exclude no-persistence elements, e.g. virtual ones
    .map (([key]) => key)
    .sort((k1, k2) => { // sort with keys first
      if (persistenceKeyNames.includes(k1)  && !persistenceKeyNames.includes(k2)) return -1
      if (!persistenceKeyNames.includes(k1) && persistenceKeyNames.includes(k2))  return 1
      return 0 // preserve original order otherwise
    })
    .join(',') // using comma as csv separator by default
}

// Logic is taken from cds-compile
function getNamespace(csn, artifactName) {
  const parts = artifactName.split('.');
  let seen = parts[0];
  const art = csn.definitions[seen];

  // First step is not a namespace (we faked those in the CSN)
  // No subsequent step can be a namespace then
  if (art && art.kind !== 'namespace' && art.kind !== 'context')
    return null;


  for (let i = 1; i < parts.length; i++) {
    // This was definitely a namespace so far
    const previousArtifactName = seen;
    seen = `${seen}.${parts[i]}`;
    // This might not be - if it isn't, return the result.
    const currentArtifact = csn.definitions[seen];
    if (currentArtifact && currentArtifact.kind !== 'namespace' && currentArtifact.kind !== 'context')
      return previousArtifactName;
  }
  // We came till here - so the full artifactName is a namespace
  return artifactName;
}
