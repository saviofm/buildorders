const { join } = require('path');
const cds = require('../../../cds')
const { read, write, exists, rmdir } = cds.utils
const commandUtil = require('../../../util/command');
const mvnArchetypes = require('../../util/mvn');
const term = require('../../../util/term');
const { mergeJSON, mergeYAML, removeFromYAML, removeFromYAMLArray } = require('../../util/merge')
const { parseMd5File, writeMd5File } = require('../../util/md5')
const { copyFiles } = require('../../util/template')
const { readProject } = require('../../util/projectReader');

const { OPTIONS: { JAVA }, URLS } = require('../../constants');

const { srvNode4, srvJava4, hdbDeployer, serviceManager, hdiContainer, mtxSidecar4 } = require('../_merging/registry-mta');

module.exports = class HanaTemplate extends require('../templateBase') {

    static hasFacet(env) {
        return env.requires?.db?.kind === 'hana'
    }

    async run() {
        const project = await readProject(this.options)
        const { isJava, configFile } = project
        project.shortcut = !(await read(configFile)).cds?.requires?.db?.kind

        const env = await this.getEnv() // REVISIT: Get info from project

        // REVISIT: Let cds build generate by default
        const hdiConfigPath = join(env.folders.db, 'src', '.hdiconfig')
        const hdiConfigTemplatePath = join(__dirname, 'files', 'src', '.hdiconfig')
        await mergeJSON(hdiConfigPath, hdiConfigTemplatePath)

        // REVISIT: Let csd build generate by default
        const undeployJSONPath = join(env.folders.db, 'undeploy.json')
        const undeployJSONTemplatePath = join(__dirname, 'files', 'undeploy.json')
        await mergeJSON(undeployJSONPath, undeployJSONTemplatePath)

        if (isJava) {
            await copyFiles(join(__dirname, 'files', 'db'), env.folders.db, {}, this.options.force)
            await this._updatePomXml()
        }

        await mergeJSON(configFile, join(__dirname, 'files', 'package.json.hbs'), project, { forceOverwrite: true })

        const packageJson = exists('package.json') ? await read('package.json') : undefined
        if (packageJson?.dependencies) {
            delete packageJson.dependencies['@sap/hana-client']
            await write('package.json', packageJson, { spaces: 2 })
        }
        await this.runDependentMerging()
    }

    async removeEntriesFromContext(context, key) {
        Object.keys(context.oldTrackingData).forEach(fileName => {
            if (fileName.startsWith(key)) {
              delete context.oldTrackingData[fileName];
            }
        });

        Object.keys(context.newTrackingData).forEach(fileName => {
            if (fileName.startsWith(key)) {
              delete context.newTrackingData[fileName];
            }
        });
    }

    async runDependentMerging(context = {}) {
        const project = await readProject(this.options)
        const { hasMta, hasHelm, hasHtml5Repo, isJava, isMultitenant, srvPath } = project


        if (hasMta) {
            const srv = (isJava ? srvJava4 : srvNode4)(srvPath)
            const db = isMultitenant ? serviceManager : hdiContainer
            const deletions = isMultitenant ? [{
                item: hdbDeployer,
                relationships: [{
                    removeProperty: 'name',
                    allWithin: ['modules', 'requires', 'name'],
                }]
            }, {
                item: hdiContainer,
                relationships: [{
                    removeProperty: 'name',
                    allWithin: ['modules', 'requires', 'name'],
                }]
            }] : []

            const relationships = [{
                insert: [db, 'name'],
                into: [srv, 'requires', 'name']
            }]

            if (!isMultitenant) {
                relationships.push({
                    insert: [hdiContainer, 'name'],
                    into: [hdbDeployer, 'requires', 'name']
                })
            } else {
                relationships.push({
                    insert: [serviceManager, 'name'],
                    into: [mtxSidecar4(isJava ? 'mtx/sidecar' : 'gen/mtx/sidecar'), 'requires', 'name']
                })
            }

            const modules = !isMultitenant ? [srv, hdbDeployer] : [srv]

            await mergeYAML(
                'mta.yaml',
                join(__dirname, 'files', 'mta.yaml.hbs'),
                project,
                { additions: [...modules, db].filter(a => a), deletions, relationships }
            )
        }

        if (hasHelm) {
            //in case facet is being added to the already exisiting charts folder
            let shouldUpdateTrackingFile = false;
            if(Object.keys(context).length == 0){
                shouldUpdateTrackingFile = true;
                context.oldTrackingData = context.newTrackingData = await parseMd5File(join('chart', '.cds-add-helm-files.md5'));
            }

            const HelmTemplate = require(`../helm`);
            const helmTemplate = new HelmTemplate(this.generator, context.oldTrackingData, context.newTrackingData);

            if(isMultitenant){
                shouldUpdateTrackingFile = true;

                // remove hana entries from values.yaml
                await removeFromYAML(join('chart', 'values.yaml'), ['hana-deployer', 'srv.bindings.db', 'hana']);

                // remove hana entries from Chart.yaml
                await removeFromYAMLArray(join('chart', 'Chart.yaml'), 'dependencies', 'hana-deployer');

                // remove content-deployment subchart if html5Repo doesn't exist
                if(!hasHtml5Repo) {
                    const contentDeploymentEntriesPattern = "charts/content-deployment/"
                    await this.removeEntriesFromContext(context, contentDeploymentEntriesPattern);

                    const contentDeploymentSubchartPath = join('chart', 'charts', 'content-deployment');
                    if(exists(contentDeploymentSubchartPath)) {
                        await rmdir(contentDeploymentSubchartPath);
                    }
                }

                //remove dependency since mtx plugin is added
                const isInternal = await helmTemplate.isInternal();
                await mergeYAML(
                    join('chart', 'Chart.yaml'),
                    {
                        dependencies: [
                            {
                                name: 'service-instance',
                                alias: 'hana',
                                version: '>0.0.0',
                                ...(isInternal) && { repository: 'https://int.repositories.cloud.sap/artifactory/virtual-unified-runtime-helm-dmz' }
                            }
                        ]
                    },
                    project,
                    { deletions: [{
                        item: {
                            in: `dependencies`,
                            where: [{
                                property: 'alias',
                                isEqualTo: 'hana'
                            }]
                        }
                    }]}
                )
            } else {
                await mergeYAML(
                    join('chart', 'values.yaml'),
                    join(__dirname, 'files', 'values.yaml.hbs'),
                    project
                )

                // copy content deployment chart if it is not present
                shouldUpdateTrackingFile = shouldUpdateTrackingFile | await helmTemplate.addSubChart('content-deployment');

                // add dependency entry in chart.yaml
                await helmTemplate.addDependency('content-deployment', 'hana-deployer');

                // add service instance chart if it is not present
                shouldUpdateTrackingFile = shouldUpdateTrackingFile | await helmTemplate.addSubChart('service-instance');

                // add dependency entry in chart.yaml
                await helmTemplate.addDependency('service-instance', 'hana');
            }
            if(shouldUpdateTrackingFile) await writeMd5File(join('chart', '.cds-add-helm-files.md5'), context.newTrackingData);
        }
    }

    async _updatePomXml() {
        // if called during cds init the project generation call to AT will add settings
        if (!this.options.add.has(JAVA)) {
            const mvnAddHanaArgs = mvnArchetypes.getAddHanaCmdArgs(this.options);
            try {
                await commandUtil.spawnCommand('mvn', mvnAddHanaArgs, {
                    cwd: cds.root
                });
            } catch (err) {
                // REVISIT: This should not have to be checked and tested in a facet implementation, move to Maven util
                if (err.code === 'ENOENT' && err.path === 'mvn') {
                    throw `Maven executable 'mvn' not found, follow ${term.info(URLS.MAVEN_INSTALL_HELP)} and install Maven on your machine.`
                }
                throw err;
            }
        }
    }
}
