const cds = require('../../cds');
const path = require('path');

const { PROJECT_TYPE } = require('../constants');
const { exists } = require('../../cds').utils;

module.exports = class TemplateBase {
    /**
     * @constructor
     */
    constructor(generator) {
        if (generator.options?.for && typeof generator.options?.for !== 'string') {
            throw 'The --for argument must not be empty.'
        }
        this.projectPath = cds.root;
        this.options = generator.options || {};
        this.generator = generator;
        this.name = this.constructor.name.replace(/template/i, '').replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase()

        this.cwd = this.options.cwd || process.cwd();

        this.projectName = path.basename(cds.root);
    }

    /**
     * Returns an array of required templates. These templates will also be added if not already included.
     * @function getDependencies
     * @returns {Array} Dependent facets. Default is an empty array.
     */
    getDependencies() {
        return []
    }

    /**
     * Returns an array of related facets that might change the result of applying the current facet.
     * Important: there must not be circular relationships between facets.
     * @function getRelatedFacets()
     * @returns {Array} Related facets. Default is an empty array.
     */
    getRelatedFacets() {
        return []
    }

    /**
     * Checks whether the given template should handle this request
     * @returns true, if template should handle this request, false otherwise
     * @throws Error, if request is invalid, e.g. a file exists already
     */
    async canRun() {
        return true;
    }

    // eslint-disable-next-line no-unused-vars
    static hasFacet(env, options) {
        return true;
    }

    /**
     * calls cds env and caches result
     * @returns {object} the current cds env
     */
     async getEnv(profile = 'production') {
        const cdsEnvVar = process.env.CDS_ENV
        process.env.CDS_ENV = profile
        try {
            return cds.env.for('cds');
        } finally {
            cdsEnvVar ? process.env.CDS_ENV = cdsEnvVar : delete process.env.CDS_ENV
        }
    }

    /**
     * @abstract
     * Executes the given template's merging steps which are dependent on another template.
     * The separation from `run()` is necessary to preserve templating associativity,
     * i.e. the order in which you apply them does not matter.
     * Ex.: Assume `cds add hana` is called before `cds add mta`. We want `cds add mta`
     * to create the base mta.yaml template and merge the hana mta.yaml in, but _don't_
     * want any other steps from the hana template performed (e.g. creating the .hdiconfig).
     * Separating the two let's us run this _only_ the merging part of the template.
     * In addition, this partial merging avoids cyclic template dependencies.
     */
    async runDependentMerging() {

    }

    /**
     * Executes steps for related facets that are set up for the project.
     */
    async runRelatedMerging() {
        for (const facet of this.getRelatedFacets()) {
            const Template = require('./'+facet)
            const template = new Template(this.generator)
            if (Template.hasFacet(await this.getEnv(), this.options)) await template.runDependentMerging()
        }
    }

    /**
     * @abstract
     * Executes the given template.
     * @throws Error, if handling failed.
     */
    async run() {
    }

    /**
     * @abstract
     * Called when generation is finished
     */
    async finalize() {
    }

    /**
     * Returns the project type
     * @see PROJECT_TYPE
     * @returns PROJECT_TYPE for current project
     */
    getProjectType() {
        if (exists('pom.xml')) return PROJECT_TYPE.java;
        if (exists('package.json')) return PROJECT_TYPE.nodejs;
        return PROJECT_TYPE.unknown;
    }
}
