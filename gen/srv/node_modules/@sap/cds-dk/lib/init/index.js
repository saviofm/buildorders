const path = require('path');

const term = require('../util/term');

const { OPTIONS, COMMAND_ADD, COMMAND_INIT, PROJECT_FILES, REGEX_PROJECT_NAME } = require('./constants')
const { NODEJS, JAVA, HANA, MTA,PIPELINE, SAMPLES, CF_MANIFEST } = OPTIONS

const cds = require('../cds'), { exists, readdir } = cds.utils
const LOG = console
const DEBUG = /\b(y|all|cli)\b/.test(process.env.DEBUG) ? console.debug : undefined

module.exports = class CDSGenerator {
    constructor() {
        this.cwd = process.cwd();

        this.uiConfig = [
            {
                title: `Project Name`,
                description: `Enter your project name.`,
                default: '',
                target: 'projectName',
                validate: async (value) => {
                    try {
                        cds.root = path.resolve(this.cwd, value || '.');

                        await this._validateProjectName(value);
                        await this._validateProjectFolder(path.join(this.cwd, value), this.cwd);

                        return true;
                    } catch (err) {
                        return err.message;
                    }
                },
                guiOptions: {
                    hint: 'This name is restricted to certain characters. A valid project name is compatible across platforms.',
                    mandatory: true
                }
            },
            {
                title: `Type`,
                description: `Select your runtime.`,
                default: NODEJS,
                choices: [
                    { name: 'Node.js', value: NODEJS },
                    { name: 'Java', value: JAVA }
                ],
                multiple: false,
                target: 'add',
                guiOptions: {
                    hint: `The preferred runtime can't be changed afterwards. To use a different runtime, create a new project.`,
                    mandatory: true
                }
            },
            {
                title: `Features`,
                description: `Add features to your project.`,
                default: '',
                choices: [
                    { name: 'CI/CD Pipeline Integration', value: PIPELINE },
                    { name: 'Configuration for SAP HANA Deployment', value: HANA },
                    { name: 'MTA based SAP Business Technology Platform Deployment', value: MTA },
                    // { name: 'Multitenancy', value: mtx },
                    { name: `Cloud Foundry native Deployment`, value: CF_MANIFEST }
                    // { name: `CDS Linter for custom rules`, value: lint },
                    // { name: `CDS Linter for custom rules with sample`, value: lintDev }
                ],
                multiple: true,
                target: 'add',
                guiOptions: {
                    hint: `Choose any combination of features enriching the capabilities of your project. You can also add features later with ${term.bold('cds add')}`
                }
            },
            {
                title: `Samples`,
                description: `Add sample content to your project.`,
                default: '',
                choices: [
                    { name: 'Basic Sample Files', value: SAMPLES }
                ],
                multiple: true,
                target: 'add',
                guiOptions: {
                    hint: 'Speed up your ramp-up phase with some sample files in your project.'
                }
            }
        ]
    }

    /**
     * @param {string} facets, comma separated list of templates, no blanks
     * @param {any} options, additional options
     */
    async addCmd(facets, options = {}) {
        options._cmd = COMMAND_ADD;
        options.add = facets;

        if (!facets) throw 'You must specify a facet to add to the project.'

        this._initialize(null, options);
        this._greetings(options._cmd);

        if (!PROJECT_FILES.find(exists)) {
            throw `The current folder doesn't seem to contain a project. None of the following files found: ${PROJECT_FILES.join(', ')}.`
        }

        await this._process(options);
        await this.stepEnd(options);
    }

    /**
     * @param {string} projectName, the project name
     * @param {any} options, additional options
     */
    async initCmd(projectName, options = {}) {
        await this.stepInit(projectName, options);
        await this.stepEnd();
    }

    async stepInit(projectName, options = {}) {
        options._cmd = COMMAND_INIT;

        this._initialize(projectName, options);
        this._greetings(options._cmd);

        await this._process();
    }

    _initialize(projectName, options = {}) {
        // deprecated, only for compatibility
        if (options.verbose) {
            LOG.warn(`Parameter 'verbose' is no longer supported. Use environment variable 'DEBUG=true' to obtain detailed output.`);
        }

        this.cwd = options.cwd || process.cwd();
        cds.root = path.resolve(this.cwd, projectName || '.');
        this.projectName = path.basename(cds.root);

        this.options = options;
        this._cleanupOptions();
    }

    _greetings() {
        switch (cds.cli.command) {
            case COMMAND_INIT: {
                const relativeProjectPath = path.relative(this.cwd, cds.root);
                const folderName = (relativeProjectPath ? `.${path.sep}${relativeProjectPath}` : 'current folder');
                LOG.info(`Creating new CAP project in ${term.bold(folderName)}\n`);
                break;
            }
        }

        if (this.options.force) {
            LOG.info(`Using '--force' ... existing files will be overwritten`);
        }
    }

    async _process() {
        DEBUG?.(`Project path: ${cds.root}`);

        await this._validateOptions();
        await this._fillTemplateList();

        for (const template of this.templateList) {
            const msg = `Adding feature '${template.name}'...`;
            LOG.info(msg);
            await template.run();
            await template.runRelatedMerging();
        }

        if (cds.cli.command === COMMAND_INIT) {
            const relativeProjectPath = path.relative(this.cwd, cds.root)
            LOG.info(`\nSuccessfully created project. Continue with '${term.bold('cd '+relativeProjectPath)}'.\n`)
        } else {
            LOG.info(`\nSuccessfully added features to your project.`)
        }
    }

    async _createTemplate(filename) {

        try {
            const TemplateClass = require(`./template/${filename}`);
            return new TemplateClass(this);
        } catch (err) {
            if (err.code === 'MODULE_NOT_FOUND') {
                const entries = (await readdir(path.join(__dirname, 'template')))
                    .filter(entry =>
                        !entry.startsWith('_') &&
                        !entry.endsWith('.js') &&
                        entry !== 'nodejs' &&
                        entry !== 'java'
                    );
                const fuzzySearch = require('../../bin/util/fuzzySearch');
                const [bestMatch] = fuzzySearch(filename, entries);
                LOG.info(`Unknown facet '${term.bold(filename)}'. Did you mean ${term.bold(`cds add ${bestMatch}`)}?\n\nHaven't found the proper facet yet? Here are all supported facets:\n\n  ${term.bold(entries.join('\n  '))}\n`);
                process.exit(1);
            }
            throw err;
        }
    }

    async _fillTemplateList() {
        const templates = new Map();
        for (let option of this.options.add) {
            // Compat
            if (option === 'sample-tiny') option = 'tiny-sample'
            if (option === 'kibana-logging') option = 'kibana'

            if (!templates.has(option)) {
                const template = await this._createTemplate(option);
                if (await template.canRun()) {
                    DEBUG?.(`Adding feature '${template.name}'`);
                    templates.set(option, template);
                    const deps = await template.getDependencies();
                    if (deps) {
                        deps.forEach(this.options.add.add, this.options.add) // REVISIT: Ugly add.add
                    }
                }
            }
        }

        const cmds = Object.values(OPTIONS)
        this.templateList = Array.from(templates.entries())
            .sort(([a], [b]) => cmds.indexOf(a) - cmds.indexOf(b))
            .map((entry) => entry[1])

        // check debug to avoid lengthy computation when not in debug mode
        DEBUG?.(`Features: ${this.templateList.map(({name}) => name).join(', ')}`);
    }

    async stepEnd() {
        for (const template of this.templateList) {
            await template.finalize();
        }
    }

    _cleanupOptions() {
        let tokens = [];

        if (typeof this.options.add === 'string') {
            tokens = this.options.add.split(/[,\s+]/g);

        } else if (Array.isArray(this.options.add)) {
            tokens = this.options.add

        } else if (this.options.add instanceof Set) {
            tokens = [...this.options.add];
        }

        const trimmedTokens = tokens.map((token) => {
            token = token.replace(/\s+/g, '');
            const tokens = token.split(':'), [facet] = tokens
            if (tokens.length > 1) {
                if (this.options[facet]) {
                    this.options[facet].add(token);
                } else {
                    this.options[facet] = new Set([token]);
                }
            }
            return facet;
        }).filter(Boolean);

        // set is ordered ... always
        this.options.add = new Set(trimmedTokens);

        if (this.options._cmd === COMMAND_INIT && !this.options.add.has(JAVA)) {
            this.options.add.add(NODEJS);
        }

        this._checkAdditionalOptions();
    }

    _checkAdditionalOptions() {
        for (const [key] of Object.entries(this.options)) {
            const keySplit = key.split(/:/);
            if (keySplit.length === 2) {
                if (!this.options.add.has(keySplit[0])) {
                    LOG.warn(`ignoring option ${key} since ${keySplit[0]} is not part of specified feature list: ${Array.from(this.options.add).join(', ')}`);
                }
            }
        }
    }

    async _validateOptions() {
        if (this.options.force) {
            return;
        }

        if (this.options._cmd === COMMAND_INIT) {
            await this._validateProjectName(this.projectName);
            await this._validateProjectFolder(this.cwd);
        }
    }

    async _validateProjectName(projectName) {
        if (!projectName) {
            throw 'Specify a project name.'
        }

        // remove duplicates by using a set
        const invalidChars = new Set(projectName.match(REGEX_PROJECT_NAME));
        switch (invalidChars.size) {
            case 0:
                break;
            case 1:
                throw `Project name ${projectName} contains an invalid character (${[...invalidChars].join(', ')}). Specify a different project name.`
            default:
                throw `Project name ${projectName} contains invalid characters (${[...invalidChars].join(', ')}). Specify a different project name.`
        }
    }

    async _validateProjectFolder(cwd) {
        const existingProjectFile = PROJECT_FILES.find(exists)
        if (existingProjectFile) {
            let message;
            if (cwd === cds.root) {
                message = `You seem to be working in a project which is already initialized. Use ${term.bold('cds add')} to add more features.`;
            } else {
                message = `You seem to be trying to initialize an existing project. Use a different project name instead.`;
            }
            throw `${message}\nDetails: File '${existingProjectFile}' exists in the project folder which indicates an existing project. Use ${term.bold('cds add')} to add more features.`
        }
    }
}
