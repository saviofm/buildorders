const cds = require('../../index')
const {join} = cds.utils.path

class ProtocolAdapter {

  /**
   * Provides canonicalized protocols configurations
   */
  static init (protocols = { ...cds.env.protocols }) {
    return this.protocols = protocols
  }

  /**
   * Returns the middleware impl for the given protocol
   */
  static middlewareFor (p) {
    const conf = this.protocols[p] || (this.protocols[p] = {})
    let { impl = join(__dirname,p) } = conf; if (typeof impl !== 'function') {
      try { require.resolve(impl) } catch { cds.error `Cannot find protocol adapter implementation: ${impl}` }
      impl = conf.impl = require(impl)
    }
    return impl
  }

  /**
   * Constructs a new adapter for the given service, or returns a formerly constructed one
   */
  static for (srv, p = srv.options?.to || protocol4(srv.definition)) { // TODO default for param p? 
    const cache = srv._adapters || (srv._adapters={}); if (p in cache) return cache[p]
    const impl = this.middlewareFor(p), conf = this.protocols[p]
    return cache[p] = impl (srv, conf)
  }

  /**
   * Returns the defined protocols for the given service
   */
  static protocols4 (def) {
    // String, provided via srv.options.to
    if(typeof def === 'string') {
      return [{ kind: def }]
    }
  
    // @protocol
    let atProtocol = def?.['@protocol']
    if (atProtocol) {
      if (!Array.isArray(atProtocol)) atProtocol = [atProtocol]
      return atProtocol.map(p => typeof p === 'string' ? { kind: p } : p)
    }
  
    // @odata, @rest, ...
    const atProtocolDirect = Object.keys(this.protocols).find(p => def?.['@'+p])
    if (atProtocolDirect) return [{ kind: atProtocolDirect }]
  
    // No protocol annotation found -> serve odata
    return [{ kind: Object.keys(this.protocols)[0] || 'odata-v4' }]
  }

  /**
   * Constructs a new adapter for the given service, and mounts it to an express app.
   */
  static serve (srv, /* in: */ app, { before, after } = cds.middlewares) {
    const DEBUG = cds.debug('adapters')
    const protocols = this.protocols4(srv.options?.to || srv.definition)

    if (protocols.length > 1 && !cds.requires.middlewares) {
      cds.error `Cannot serve multiple protocols if cds.requires.middlewares is set to false`
    }

    const srvDefPath = srv.definition?.['@path']
    if (protocols.length > 1 && srvDefPath?.[0] === '/') {
      cds.error `Cannot serve entity with absolute @path (starting with '/') for more than one protocol`
    }

    let adapter, path, prefix
    for (let p of protocols) {
      adapter = this.for(srv, p.kind); if (!adapter) continue
      path = srv.options?.at || srv.options?.path || p.path || srvDefPath || cds.service.path4(srv).slice(1)

      if (path[0] !== '/') {
        if (protocols.length === 1 && cds.env.features.serve_on_root) {
          app.use (`/${path}/webapp/`, (_,res) => res.sendStatus(404))
          DEBUG?.('app.use(', path, ', ... )')
          app.use (`/${path}`, before, adapter, after)
        }

        prefix = this.protocols[p.kind].path
        prefix = prefix ? (prefix.endsWith('/') ? prefix : prefix + '/') : '/'
        path = prefix + path
      }

      DEBUG?.('app.use(', path, ', ... )')
      app.use (path, before, adapter, after)
      // REVISIT this doesn't handle multiple protocols correctly
      srv.path = path
    }
  }
}

const protocols = Object.keys(ProtocolAdapter.init())
// REVISIT remove protocol4 (and protocols variable)
const protocol4 = (def, _default = protocols[0] || 'odata-v4') => def?.['@protocol'] || protocols.find(p => def['@'+p]) || _default

module.exports = { ProtocolAdapter, protocol4 }
if (!cds.env.protocols && !cds.requires.middlewares) {
  module.exports.ProtocolAdapter = require('./_legacy')
}
