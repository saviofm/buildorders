const cds = require('../../../../cds')

const { UNAUTHORIZED, FORBIDDEN, getRequiresAsArray, isRestricted } = require('../../../../auth/utils')

module.exports = srv => {
  const requires = getRequiresAsArray(srv.definition)
  const restricted = isRestricted(srv)

  return function ODataRequestHandler(odataReq, odataRes, next) {
    const req = odataReq.getBatchApplicationData()
      ? odataReq.getBatchApplicationData().req
      : odataReq.getIncomingRequest()

    // REVISIT: ensure there always is a user (should be the case with new middlewares -> remove with old middlewares)
    // prettier-ignore
    if (!req.user) req.user = new cds.User.default

    const { res, user, path, headers } = req

    const { protectMetadata } = cds.env.odata
    if (protectMetadata === false && (path === '/' || path.endsWith('/$metadata'))) {
      // > nothing to do
      return next()
    }

    // in case of $batch we need to challenge directly, as the header is not processed if in $batch response body
    if (restricted && path.endsWith('/$batch') && req.user._is_anonymous) {
      // NOTE: "return req._login()" would not invoke custom error handlers
      if (req._login) res.set('WWW-Authenticate', `Basic realm="Users"`)
      else if (user._challenges) res.set('WWW-Authenticate', user._challenges.join(';'))
      return next(UNAUTHORIZED)
    }

    // check @requires as soon as possible (DoS)
    if (requires && !requires.some(r => user.is(r))) {
      // > unauthorized or forbidden?
      if (req.user._is_anonymous) {
        // NOTE: "return req._login()" would not invoke custom error handlers
        if (req._login) res.set('WWW-Authenticate', `Basic realm="Users"`)
        else if (user._challenges) res.set('WWW-Authenticate', user._challenges.join(';'))
        return next(UNAUTHORIZED)
      }
      return next(FORBIDDEN)
    }

    /*
     * .on('request') is the only possibility to set a shared object,
     * that can be used in ATOMICITY_GROUP_START and ATOMICITY_GROUP_END
     */
    if (path.endsWith('/$batch')) {
      // ensure content type
      const ct = headers['content-type'] || ''
      if (!ct.match(/multipart\/mixed/) && !ct.match(/application\/json/)) {
        return next({
          statusCode: 400,
          code: '400',
          message: 'Batch requests must have content type multipart/mixed or application/json'
        })
      }

      odataReq.setApplicationData({ req, res })
    }

    next()
  }
}
